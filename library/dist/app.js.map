{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"vue\"","webpack:///external \"quasar\"","webpack:///./src/_common.js","webpack:///./src/store.js","webpack:///./src/uuid.js","webpack:///./src/factory.js","webpack:///./src/timer.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","getCases","text","cases","includes","lower","toLowerCase","camel","replace","g","toUpperCase","pascal","substr","upsertPrefix","deletePrefix","getCollectionPrefixes","mapState","fields","props","Array","isArray","forEach","this","$store","state","commit","keys","mapStoreMutations","Model","reduce","mutations","set","mapStoreCollections","collections","actions","getters","some","collection","type","setPropertyOfACollectionItem","index","id","undefined","single","plural","item","push","delete","properties","names","conjunction","match","dispatch","map","indice","Map","mapStoreComplexTypes","complexTypes","complexType","typeName","setCollectionPrefixes","mapGetters","mapCollectionItemState","moduleName","computed","getEntityById","entityName","propName","actionName","entity","scope","upsertAction","setModuleName","mapComplexTypeState","comb","date","Date","uuid","getTime","toString","slice","extract","time","parseInt","component","render","setup","createElement","factories","options","__value","$emit","methods","args","root","$refs","apply","renders","filter","setups","h","wrapper","self","$vnode","ref","scopedSlots","$scopedSlots","attrs","$attrs","values","$props","input","listeners","$listeners","on","__component","merge","model","user","condition","length","merged","isFunc","__merged","JSON","parse","stringify","reBrand","brand","style","class","prop","default","store","initialize","field","obj","preperValidation","namespaced","context","page","storeModule","preFetch","created","mounted","destroyed","checkModule","success","failure","mutationName","_mutations","currentRoute","previousRoute","redirect","unregisterModule","registerModule","route","from","next","then","preserveState","alreadyInitialized","$route","$router","defaultPrefixes","camelName","pascalName","sleep","delay","Promise","resolve","setTimeout","factory","timer"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"vue\");","module.exports = require(\"quasar\");","const getCases = function (text) {\r\n  let cases = {}\r\n  if (text.includes('-')) {\r\n    cases.lower = text.toLowerCase()\r\n    cases.camel = cases.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });\r\n    cases.pascal = cases.camel[0].toUpperCase() + cases.camel.substr(1)\r\n  } else {\r\n    cases.camel = text[0].toLowerCase() + text.substr(1)\r\n    cases.pascal = text[0].toUpperCase() + text.substr(1)\r\n  }\r\n  return cases\r\n}\r\n\r\nexport {\r\n  getCases\r\n}\r\n\r\nexport default {\r\n  getCases\r\n}\r\n","import Vue from 'vue'\r\nimport { getCases } from './_common'\r\n\r\nconst defaultPrefixes = {\r\n  upsertPrefix: 'saveOrUpdate',\r\n  deletePrefix: 'delete'\r\n}\r\n\r\nconst getCollectionPrefixes = function () {\r\n  return defaultPrefixes\r\n}\r\n\r\nconst setCollectionPrefixes = function ({ upsertPrefix, deletePrefix }) {\r\n  defaultPrefixes.upsertPrefix = upsertPrefix || defaultPrefixes.upsertPrefix\r\n  defaultPrefixes.deletePrefix = deletePrefix || defaultPrefixes.deletePrefix\r\n}\r\n\r\n/**\r\n * maps all fields to a computed-like object who getters access the state and the setters do mutations.\r\n * @param {String} module - the module name\r\n * @param {String[] | Object} fields - fields can be an array of strings or a object where the keys and values are strings. e.g:` ['text', 'number', 'list']` or `{ text: 'text', number: 'number', collection: 'list' }`\r\n * @returns {Object} \r\n */\r\nconst mapState = function (module, fields) {\r\n  var props = {}\r\n  if (Array.isArray(fields)) {\r\n    fields.forEach(property => {\r\n      props[property] = {\r\n        get () {\r\n          return this.$store.state[module][property]\r\n        },\r\n        set (value) {\r\n          this.$store.commit(`${module}/${property}`, value)\r\n        }\r\n      }\r\n    })\r\n  } else {\r\n    Object.keys(fields).forEach(key => {\r\n      var property = fields[key]\r\n      props[key] = {\r\n        get () { return this.$store.state[module][property] },\r\n        set (value) { this.$store.commit(`${module}/${property}`, value) }\r\n      }\r\n    })\r\n  }\r\n  return props\r\n}\r\n\r\n/**\r\n * maps all fields to a computed-like object who getters access the getters and the setters do mutations.\r\n * @param {String} module - the module name\r\n * @param {String[] | Object} fields - fields can be an array of strings or a object where the keys and values are strings. e.g:` ['text', 'number', 'list']` or `{ text: 'text', number: 'number', collection: 'list' }`\r\n * @returns {Object} \r\n */\r\nconst mapGetters = function (module, fields) {\r\n  let props = {}\r\n  if (Array.isArray(fields)) {\r\n    fields.forEach(property => {\r\n      props[property] = {\r\n        get () {\r\n          return this.$store.getters[`${module}/${property}`]\r\n        },\r\n        set (value) {\r\n          this.$store.commit(`${module}/${property}`, value)\r\n        }\r\n      }\r\n    })\r\n  } else {\r\n    Object.keys(fields).forEach(key => {\r\n      let property = fields[key]\r\n      props[key] = {\r\n        get () { return this.$store.getters[`${module}/${property}`] },\r\n        set (value) { this.$store.commit(`${module}/${property}`, value) }\r\n      }\r\n    })\r\n  }\r\n  return props\r\n}\r\n\r\n/**\r\n * maps all classes fields to a mutations-like object.\r\n * @param {*} Model - class used to model the mutations object \r\n * @returns {Object} a object with the mapped mutations\r\n */\r\nconst mapStoreMutations = function (Model) {\r\n  const keys = Object.keys(new Model())\r\n  const mutations = keys.reduce((mutations, key) => {\r\n    mutations[key] = function (state, value) {\r\n      Vue.set(state, key, value)\r\n    }\r\n    return mutations\r\n  }, {})\r\n  return mutations\r\n}\r\n\r\n/**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} CollectionItem\r\n * @property {String} single - the single form of the collection (item, person, job)\r\n * @property {String} plural - the plural form of the collection (list, people, jobs), would be the same as in the state\r\n * @property {String} id - the name of the id field of the object in the collection\r\n * @property {Object} type - the type of the objects in the array\r\n * @property {String} [upsertPrefix='saveOrUpdate'] - prefix of the save or update action\r\n * @property {String} [deletePrefix='delete'] - prefix of the delete action\r\n */\r\n\r\n/**\r\n * Create `mutations` (create, update, delete, setters), `actions` (upsert, delete, setters) and `getters` (index, getById) related to array fields.\r\n * @param {CollectionItem[]} collections - an array of objects that describes your collection\r\n * @returns {Object} a object with the mapped mutations, actions and getters\r\n */\r\nconst mapStoreCollections = function (collections) {\r\n  let mutations = {}\r\n  let actions = {}\r\n  let getters = {}\r\n  let hasTypes = collections.some(collection => collection.type !== void 0)\r\n  if (hasTypes) {\r\n    mutations.setPropertyOfACollectionItem = function (state, { index, collection, property, value }) {\r\n      Vue.set(state[collection][index], property, value)\r\n    }\r\n    actions.setPropertyOfACollectionItem = function ({ commit, getters }, { id, collection, property, value }) {\r\n      const index = getters[collection + 'Index'].get(id)\r\n      if (index !== undefined) {\r\n        commit('setPropertyOfACollectionItem', { index, collection, property, value })\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let collection of collections) {\r\n    let single = getCases(collection.single)\r\n    let plural = getCases(collection.plural)\r\n\r\n    mutations[`create${single.pascal}`] = function (state, item) {\r\n      state[collection.plural].push(item)\r\n    }\r\n    mutations[`update${single.pascal}`] = function (state, { index, item }) {\r\n      Vue.set(state[collection.plural], index, item)\r\n    }\r\n    mutations[`delete${single.pascal}`] = function (state, index) {\r\n      Vue.delete(state[collection.plural], index)\r\n    }\r\n\r\n    let upsertPrefix = collection.upsertPrefix || defaultPrefixes.upsertPrefix\r\n    let deletePrefix = collection.deletePrefix || defaultPrefixes.deletePrefix\r\n    actions[`${upsertPrefix}${single.pascal}`] = function ({ commit, getters }, item) {\r\n      let index = getters[`${plural.camel}Index`].get(item[collection.id])\r\n      if (index !== void 0) {\r\n        commit(`update${single.pascal}`, { index, item })\r\n      } else {\r\n        commit(`create${single.pascal}`, item)\r\n      }\r\n    }\r\n    actions[`${deletePrefix}${single.pascal}`] = function ({ commit, getters }, id) { \r\n      let index = getters[`${plural.camel}Index`].get(id)\r\n      if (index !== void 0) {\r\n        commit(`delete${single.pascal}`, index)\r\n      }\r\n    }\r\n\r\n    if (collection.type !== void 0) {\r\n      let properties = Object.keys(new collection.type())\r\n      for (const property of properties) {\r\n        const names = getCases(property)\r\n        let conjunction = single.pascal.match(/^[aeiou].*/i) ? 'An' : 'A'\r\n        actions[`set${names.pascal}Of${conjunction}${single.pascal}`] = function ({ dispatch }, { id, value }) {\r\n          return dispatch('setPropertyOfACollectionItem', { id, collection: collection.plural, property, value })\r\n        }\r\n      }\r\n    }\r\n\r\n    getters[`${plural.camel}Index`] = function (state) {\r\n      let _collection = state[collection.plural] || []\r\n      return _collection.reduce((map, item, indice) => {\r\n        map.set(item[collection.id], indice)\r\n        return map\r\n      }, new Map())\r\n    }\r\n    getters[`${single.camel}ById`] = function (state, getters) {\r\n      return (id) => {\r\n        let index = getters[`${plural.camel}Index`].get(id)\r\n        return index !== void 0 ? state[collection.plural][index] : null\r\n      }\r\n    }\r\n  }\r\n  \r\n  return {\r\n    mutations,\r\n    actions,\r\n    getters\r\n  }\r\n}\r\n\r\n /**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} ComplexType\r\n * @property {String} name - the name of the field\r\n * @property {Object} type - the type of the object\r\n */\r\n\r\n/**\r\n * Create `mutations` (setters) related to complex fields.\r\n * @param {ComplexType[]} complexTypes - an array of objects that describes your collection\r\n * @returns {Object} a object with the mapped mutations\r\n */\r\nconst mapStoreComplexTypes = function (complexTypes) {\r\n  let mutations = {}\r\n  for (let complexType of complexTypes) {\r\n    let properties = Object.keys(new complexType.type())\r\n    let typeName = getCases(complexType.name)\r\n    for (const property of properties) {\r\n      const name = getCases(property)\r\n      mutations[`set${name.pascal}Of${typeName.pascal}`] = function (state, value) {\r\n        Vue.set(state[complexType.name], property, value)\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    mutations\r\n  }\r\n}\r\n\r\n/**\r\n * Create `mutations` (setters) related to complex fields.\r\n * @param {String} module - the module name\r\n * @param {CollectionItem} params - an array of objects that describes your collection\r\n * @returns {Object} a object with the mapped mutations\r\n */\r\nconst mapCollectionItemState = function (module, { id, single, type, upsertPrefix }) {\r\n  let moduleName = module\r\n  let setModuleName = function (name) {\r\n    moduleName = name\r\n  }\r\n  let name = getCases(single)\r\n  let computed = {}\r\n\r\n  let getEntityById = `${name.camel}ById`\r\n  let entityName = `__${single}`\r\n  computed[getEntityById] = function () {\r\n    return this.$store.getters[`${moduleName}/${getEntityById}`]\r\n  }\r\n  computed[entityName] = function () {\r\n    return this[getEntityById](this[id])\r\n  }\r\n\r\n  let properties = Object.keys(new type())\r\n  for (const property of properties) {\r\n    const propName = getCases(property)\r\n    let conjunction = name.camel.match(/^[aeiou].*/i) ? 'An' : 'A'\r\n    let actionName = `set${propName.pascal}Of${conjunction}${name.pascal}`\r\n    computed[property] = {\r\n      get () {\r\n        return this[entityName][property]\r\n      },\r\n      set (value) {\r\n        this.$store.dispatch(`${moduleName}/${actionName}`, { id: this[id], value })\r\n      }\r\n    }\r\n  }\r\n\r\n  upsertPrefix = upsertPrefix || defaultPrefixes.upsertPrefix\r\n  computed[single] = {\r\n    get () {\r\n      let entity = {}\r\n      let scope = this\r\n      for (const property of properties) {\r\n        Object.defineProperty(entity, property, {\r\n          get () { return scope[property] },\r\n          set (value) { scope[property] = value }\r\n        })\r\n      }\r\n      return entity\r\n    },\r\n    set (value) {\r\n      let upsertAction = `${moduleName}/${upsertPrefix}${name.pascal}`\r\n      this.$store.dispatch(upsertAction, value)\r\n    }\r\n  }\r\n\r\n  return {\r\n    setModuleName,\r\n    computed\r\n  }\r\n}\r\n\r\n/**\r\n * Create `mutations` (setters) related to complex fields.\r\n * @param {String} module - the module name\r\n * @param {ComplexType} params - an array of objects that describes your collection\r\n * @returns {Object} a object with the mapped mutations\r\n */\r\nconst mapComplexTypeState = function (module, { name, type }) {\r\n  let moduleName = module\r\n  let setModuleName = function (name) {\r\n    moduleName = name\r\n  }\r\n  let single = getCases(name)\r\n  let computed = {}\r\n\r\n  let properties = Object.keys(new type())\r\n  for (const property of properties) {\r\n    const propName = getCases(property)\r\n    let actionName = `set${propName.pascal}Of${single.pascal}`\r\n    computed[property] = {\r\n      get () {\r\n        return this.$store.state[moduleName][name][property]\r\n      },\r\n      set (value) {\r\n        this.$store.commit(`${moduleName}/${actionName}`, value)\r\n      }\r\n    }\r\n  }\r\n\r\n  computed[name] = {\r\n    get () {\r\n      let entity = {}\r\n      let scope = this\r\n      for (const property of properties) {\r\n        Object.defineProperty(entity, property, {\r\n          get () { return scope[property] },\r\n          set (value) { scope[property] = value }\r\n        })\r\n      }\r\n      return entity\r\n    },\r\n    set (value) {\r\n      this.$store.commit(`${moduleName}/${name}`, value)\r\n    }\r\n  }\r\n\r\n  return {\r\n    setModuleName,\r\n    computed\r\n  }\r\n}\r\n\r\nexport {\r\n  getCollectionPrefixes,\r\n  setCollectionPrefixes,\r\n  mapState,\r\n  mapGetters,\r\n  mapStoreMutations,\r\n  mapStoreCollections,\r\n  mapStoreComplexTypes,\r\n  mapCollectionItemState,\r\n  mapComplexTypeState\r\n}\r\n\r\nexport default {\r\n  getCollectionPrefixes,\r\n  setCollectionPrefixes,\r\n  mapState,\r\n  mapGetters,\r\n  mapStoreMutations,\r\n  mapStoreCollections,\r\n  mapStoreComplexTypes,\r\n  mapCollectionItemState,\r\n  mapComplexTypeState\r\n}\r\n","import { uid } from 'quasar'\r\n\r\n/**\r\n * creates a comb (combined time-uuid)\r\n * @param {*} date - date used to create the COMB\r\n * @returns {String} returns a combined time-uuid (comb)\r\n */\r\nconst comb = function (date) {\r\n  if (!date) {\r\n    date = new Date()\r\n  }\r\n  let uuid = uid()\r\n  let comb = ('00000000000' + date.getTime().toString(16)).substr(-12)\r\n  comb = comb.slice(0, 8) + '-' + comb.slice(8, 12)\r\n  return uuid.replace(uuid.slice(0, 13), comb)\r\n}\r\n\r\n/**\r\n * extract the date part of the comb\r\n * @param {String} comb a combined time-uuid (comb)\r\n * @returns {Date} the date part of the comb\r\n */\r\nconst extract = function (comb) {\r\n  let text = comb.replace(/-/g, '').substr(0, 12)\r\n  let time = parseInt(text, 16)\r\n  return new Date(time)\r\n}\r\n\r\nexport {\r\n  comb,\r\n  extract\r\n}\r\n\r\nexport default {\r\n  comb,\r\n  extract\r\n}\r\n","\r\nimport Vue from 'vue'\r\nimport { mapState, mapStoreMutations, mapStoreCollections, mapStoreComplexTypes, getCollectionPrefixes } from './store'\r\nimport uuid from './uuid'\r\nimport { getCases, getPeer } from './_common'\r\n\r\n/**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} ComponentFactory\r\n * @param {Function} render - callback function that is called everytime the component is rendered: render ({ self, options }) { }\r\n * @param {Function} setup - callback function that is called when the component is ready to be returned: setup({ component }) { }\r\n */\r\n\r\n /**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} CollectionItem\r\n * @property {String} single - the single form of the collection (item, person, job)\r\n * @property {String} plural - the plural form of the collection (list, people, jobs), would be the same as in the state\r\n * @property {String} id - the name of the id field of the object in the collection\r\n * @property {Object} type - the type of the objects in the array\r\n * @property {String} [upsertPrefix='saveOrUpdate'] - prefix of the save or update action\r\n * @property {String} [deletePrefix='delete'] - prefix of the delete action\r\n */\r\n\r\n /**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} ComplexType\r\n * @property {String} name - the name of the field\r\n * @property {Object} type - the type of the object\r\n */\r\n\r\n/**\r\n * wrapper a component and allow them to be modified at the render time, or even setup your properties, slots, etc.\r\n * @param {Object} param\r\n * @param {String} param.name - component's name\r\n * @param {Object} param.component - component to be wrapped\r\n * @param {Function} param.render - callback function that is called everytime the component is rendered: render ({ self, options }) { }\r\n * @param {Function} param.setup - callback function that is called when the component is ready to be returned: setup({ component }) { }\r\n * @param {Function} [param.createElement=function (h, component, options) {\r\n     return h(component, options)\r\n   }]\r\n * @param {ComponentFactory[]} param.factories - array of objects with a render and/or setup field\r\n */\r\nconst component = function ({ name, component, render, setup, createElement, factories }) {\r\n  const props = component.options.props\r\n  const computed = {}\r\n  if (props.value) {\r\n    computed.__value = {\r\n      get () { return this.value },\r\n      set (value) { return this.$emit('input', value) }\r\n    }\r\n  }\r\n  const methods = Object.keys(component.options.methods || {}).reduce((methods, key) => {\r\n    methods[key] = function (...args) {\r\n      let root = this.$refs.root\r\n      return root[key].apply(root, args)\r\n    }\r\n    return methods\r\n  }, {})\r\n\r\n  factories = factories || []\r\n  const renders = factories.filter(item => item.render).map(item => item.render)\r\n  if (render) {\r\n    renders.push(render)\r\n  }\r\n\r\n  const setups = factories.filter(item => item.setup).map(item => item.setup)\r\n  if (setup) {\r\n    setups.push(setup)\r\n  }\r\n\r\n  if (!createElement) {\r\n    createElement = function (h, component, options) {\r\n      return h(component, options)\r\n    }\r\n  }\r\n  let wrapper = {\r\n    name: name,\r\n    props: props,\r\n    methods: methods,\r\n    computed: computed,\r\n    render (h) {\r\n      let self = this\r\n      let key = this.$vnode.key\r\n      let options = {\r\n        key: key,\r\n        ref: 'root',\r\n        scopedSlots: this.$scopedSlots,\r\n        attrs: this.$attrs\r\n      }\r\n      if (props.value) {\r\n        let { values, ...props } = this.$props\r\n        let { input, ...listeners } = this.$listeners\r\n        props.value = self.__value\r\n        listeners.input = function (value) {\r\n          self.__value = value\r\n        }\r\n        options.props = props\r\n        options.on = listeners\r\n      } else {\r\n        let { ...props } = this.$props\r\n        let { ...listeners } = this.$listeners\r\n        options.props = props\r\n        options.on = listeners\r\n      }\r\n\r\n      for (let render of renders) {\r\n        render({ self, options })\r\n      }\r\n      return createElement(h, component, options)\r\n    }\r\n  }\r\n  for (let setup of setups) {\r\n    setup({ component: wrapper })\r\n  }\r\n  return wrapper\r\n}\r\n\r\nconst __component = component\r\n\r\n/**\r\n * @param {String} name\r\n * @param {Object} component\r\n * @param {Object} brand\r\n * @param {String|Object|Array} brand.style\r\n * @param {String|Object|Array} brand.class\r\n * @param {Object} brand.props\r\n */\r\nconst reBrand = function (name, component, brand) {\r\n  var keys = Object.keys(brand.props || {})\r\n  Vue.component(name, __component({\r\n    name: component.name,\r\n    component,\r\n    render ({ self, options }) {\r\n      if (brand.style) {\r\n        options.style = brand.style\r\n      }\r\n      if (brand.class) {\r\n        options.class = brand.class\r\n      }\r\n      for (const prop of keys) {\r\n        options.props[prop] = options.props[prop] === undefined ? brand.props[prop] : options.props[prop]\r\n      }\r\n      return null\r\n    },\r\n    setup ({ component }) {\r\n      for (const prop of keys) {\r\n        component.props[prop].default = () => undefined\r\n      }\r\n    }\r\n  }))\r\n}\r\n\r\nconst merge = function ({ name, model, collections, complexTypes, user }) {\r\n  let conditions = [\r\n    model && model[name],\r\n    collections && collections[name],\r\n    !!user\r\n  ].filter(condition => condition)\r\n\r\n  if (conditions.length > 1) {\r\n    let merged = {}\r\n    let isFunc = false\r\n    if (user) {\r\n      isFunc = isFunc || user.call\r\n      merged = user.call ? { ...merged, ...user() } : { ...merged, ...user }\r\n    }\r\n    if (model && model[name]) {\r\n      isFunc = isFunc || model[name].call\r\n      merged = model[name].call ? { ...merged, ...model[name]() } : { ...merged, ...model[name] }\r\n    }\r\n    if (collections && collections[name]) {\r\n      isFunc = isFunc || collections[name].call\r\n      merged = collections[name].call ? { ...merged, ...collections[name]() } : { ...merged, ...collections[name] }\r\n    }\r\n    if (complexTypes && complexTypes[name]) {\r\n      isFunc = isFunc || complexTypes[name].call\r\n      merged = complexTypes[name].call ? { ...merged, ...complexTypes[name]() } : { ...merged, ...complexTypes[name] }\r\n    }\r\n    if (isFunc) {\r\n      let __merged = merged\r\n      merged = function () {\r\n        return JSON.parse(JSON.stringify(__merged))\r\n      }\r\n    }\r\n    return merged\r\n  } else if (model && model[name]) {\r\n    return model[name]\r\n  } else if (collections && collections[name]) {\r\n    return collections[name]\r\n  } else if (complexTypes && complexTypes[name]) {\r\n    return complexTypes[name]\r\n  } else {\r\n    return user\r\n  }\r\n}\r\n\r\nconst preperValidation = function ({ store, field }) {\r\n  store.mutations = store.mutations || {}\r\n  store.mutations[field] = function (state, value) { state[field] = value }\r\n  \r\n  store.state = store.state || {}\r\n  let isFunc = !!store.state.call\r\n  if (isFunc) {\r\n    store.state = store.state()\r\n  }\r\n  store.state[field] = 0\r\n  if (isFunc) {\r\n    let obj = store.state\r\n    store.state = function () {\r\n      return { ...obj }\r\n    }\r\n  }\r\n}\r\n\r\nconst validationField = '@@'\r\n/**\r\n * factory.store combines store.mapStoreMutations and store.mapStoreCollections.\r\n * @param {Object} param - the page properties (`created`, `computed`, `etc`)\r\n * @param {Object} param.options - options used to generate the page\r\n * @param {Object} param.options.model - class used to model the mutations object\r\n * @param {CollectionItem[]} param.options.collections - an array of objects that describes your collection\r\n * @param {ComplexType[]} param.options.collections - an array of objects that describes your collection\r\n * @param {String} param.state - module's state, that will be merged intro the final module\r\n * @param {String} param.mutations - module's mutations, that will be merged intro the final module\r\n * @param {String} param.actions - module's actions, that will be merged intro the final module\r\n * @param {String} param.getters - module's getters, that will be merged intro the final module\r\n */\r\nconst store = function ({ options, initialize, ...store }) {\r\n  let model, collections, complexTypes\r\n  if (options && options.model) {\r\n    model = {\r\n      state: function () {\r\n        return new options.model()\r\n      },\r\n      mutations: mapStoreMutations(options.model)\r\n    }\r\n  }\r\n  if (options && options.collections && options.collections.length > 0) {\r\n    collections = mapStoreCollections(options.collections)\r\n  }\r\n  if (options && options.complexTypes && options.complexTypes.length > 0) {\r\n    complexTypes = mapStoreComplexTypes(options.complexTypes)\r\n  }\r\n\r\n  preperValidation({ store, field: validationField })\r\n  store.namespaced = true\r\n  store.state = merge({ name: 'state', model, collections, complexTypes,  user: store.state })\r\n  store.mutations = merge({ name: 'mutations', model, collections, complexTypes, user: store.mutations }) || {}\r\n  store.actions = merge({ name: 'actions', model, collections, complexTypes, user: store.actions }) || {}\r\n  store.getters = merge({ name: 'getters', model, collections, complexTypes, user: store.getters })\r\n  if (!store.actions.initialize) {\r\n    store.actions.initialize = initialize || function (context, values) {}\r\n  }\r\n  return store\r\n}\r\n\r\n/**\r\n * factory.page will expect the same options as factory.store and will map the state, mutations, actions and getters generated by factory.store to the page.\r\n * @param {Object} param - the page properties (`created`, `computed`, `etc`)\r\n * @param {Object} param.options - options used to generate the page\r\n * @param {Object} param.options.model - class used to model the mutations object\r\n * @param {CollectionItem[]} param.options.collections - an array of objects that describes your collection\r\n * @param {Object} param.storeModule - if not null, it'll be registered in the preFetch or in the created hook, and removed in the destroyed hook.\r\n * @param {String} param.moduleName - the prefix of the private fields used by the getters and setters\r\n */\r\nconst page = function ({ options, storeModule, moduleName, ...page }) {\r\n  let { preFetch, created, mounted, destroyed } = page\r\n\r\n  const checkModule = function ({ store, success, failure }) {\r\n    if (storeModule.mutations[validationField]) {\r\n      let comb = uuid.comb()\r\n      let mutationName = `${moduleName}/${validationField}`\r\n      if (store.state[moduleName] && store._mutations[mutationName]) {\r\n        store.commit(mutationName, comb)\r\n        let value = (store.state[moduleName] || {})[validationField]\r\n        if (value === comb) {\r\n          if (success) success()\r\n        } else {\r\n          if (failure) failure()\r\n        }\r\n      } else if (failure) {\r\n        failure()\r\n      }\r\n    }\r\n  }\r\n\r\n  if (storeModule) {\r\n    let initialize\r\n    page.preFetch = function (context) {\r\n      let self = this\r\n      let { store, currentRoute, previousRoute, redirect } = context\r\n      checkModule({\r\n        store,\r\n        success () {\r\n          store.unregisterModule(moduleName)\r\n        }\r\n      })\r\n      store.registerModule(moduleName, storeModule)\r\n      return store.dispatch(`${moduleName}/initialize`, {\r\n        route: currentRoute,\r\n        from: previousRoute,\r\n        next: redirect\r\n      }).then(function () {\r\n        if (preFetch) {\r\n          return preFetch.apply(self, [ context ])\r\n        }\r\n      })\r\n    }\r\n  \r\n    page.created = function () {\r\n      let self = this\r\n      checkModule({\r\n        store: this.$store,\r\n        failure () {\r\n          self.$store.registerModule(moduleName, storeModule, { preserveState: alreadyInitialized })\r\n        }\r\n      })\r\n      if (created) {\r\n        created.apply(self, [])\r\n      }\r\n    }\r\n\r\n    page.mounted = function () {\r\n      let alreadyInitialized  = !!this.$store.state[moduleName]\r\n      if (!alreadyInitialized) {\r\n        const args = this.$route ? {\r\n          route: this.$route,\r\n          next: this.$router.replace.bind(this.$router)\r\n        } : undefined\r\n        this.$store.dispatch(`${moduleName}/initialize`, args)\r\n      }\r\n      if (mounted) {\r\n        mounted.apply(self, [])\r\n      }\r\n    }\r\n  \r\n    page.destroyed = function () {\r\n      let self = this\r\n      if (destroyed) {\r\n        destroyed.apply(self, [])\r\n      }\r\n      checkModule({\r\n        store: this.$store,\r\n        success () {\r\n          self.$store.unregisterModule(moduleName)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  if (options && options.model) {\r\n    let keys = Object.keys(new options.model())\r\n    page.computed = {\r\n      ...page.computed,\r\n      ...mapState(moduleName, keys)\r\n    }\r\n  }\r\n\r\n  if (options && options.collections) {\r\n    let actions = {}\r\n    let getters = {}\r\n    let defaultPrefixes = getCollectionPrefixes()\r\n    let hasTypes = options.collections.some(collection => collection.type !== void 0)\r\n    if (hasTypes) {\r\n      actions.setPropertyOfACollectionItem = function ({ id, collection, property, value }) {\r\n        return this.$store.dispatch(`${moduleName}/setPropertyOfACollectionItem`, { id, collection, property, value })\r\n      }\r\n    }\r\n\r\n    for (let collection of options.collections) {\r\n      let single = getCases(collection.single)\r\n      let plural = getCases(collection.plural)\r\n      let upsertPrefix = collection.upsertPrefix || defaultPrefixes.upsertPrefix\r\n      let deletePrefix = collection.deletePrefix || defaultPrefixes.deletePrefix\r\n      actions[`${upsertPrefix}${single.pascal}`] = function (item) {\r\n        return this.$store.dispatch(`${moduleName}/${upsertPrefix}${single.pascal}`, item)\r\n      }\r\n      actions[`${deletePrefix}${single.pascal}`] = function (id) {\r\n        return this.$store.dispatch(`${moduleName}/${deletePrefix}${single.pascal}`, id)\r\n      }\r\n      getters[`${plural.camel}Index`] = function () {\r\n        let getter = this.$store.getters[`${moduleName}/${moduleName}/${plural.camel}Index`]\r\n        if (getter) {\r\n          return getter\r\n        } else {\r\n          let state = this.$store.state[moduleName]\r\n          return storeModule.getters[`${plural.camel}Index`](state, this)\r\n        }\r\n      }\r\n      getters[`${single.camel}ById`] = function () {\r\n        let getter = this.$store.getters[`${moduleName}/${single.camel}ById`]\r\n        if (getter) {\r\n          return getter\r\n        } else {\r\n          let state = this.$store.state[moduleName]\r\n          return storeModule.getters[`${single.camel}ById`](state, this)\r\n        }\r\n      }\r\n      if (collection.type !== void 0) {\r\n        let properties = Object.keys(new collection.type())\r\n        for (const property of properties) {\r\n          let name = getCases(property)\r\n          let conjunction = single.pascal.match(/^[aeiou].*/i) ? 'An' : 'A'\r\n          let actionName = `set${name.pascal}Of${conjunction}${single.pascal}`\r\n          actions[actionName] = function ({ id, value }) {\r\n            return this.$store.dispatch(`${moduleName}/${actionName}`, { id, collection: collection.plural, property, value })\r\n          }\r\n        }\r\n      }\r\n    }\r\n    page.computed = {\r\n      ...page.computed,\r\n      ...getters\r\n    }\r\n    page.methods = {\r\n      ...page.methods,\r\n      ...actions\r\n    }\r\n  }\r\n  if (options && options.complexTypes) {\r\n    let getters = {}\r\n    for (let complexType of options.complexTypes) {\r\n      let properties = Object.keys(new complexType.type())\r\n      let typeName = getCases(complexType.name)\r\n      for (const property of properties) {\r\n        const name = getCases(property)\r\n        const camelName = `${name.camel}Of${typeName.pascal}`\r\n        const pascalName = `set${name.pascal}Of${typeName.pascal}`\r\n        getters[camelName] = {\r\n          get () {\r\n            return this.$store.state[moduleName][complexType.name][property]\r\n          },\r\n          set (value) {\r\n            this.$store.commit(`${moduleName}/${pascalName}`, value)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    page.computed = {\r\n      ...page.computed,\r\n      ...getters\r\n    }\r\n  }\r\n  return page\r\n}\r\n\r\nexport {\r\n  reBrand,\r\n  component,\r\n  store,\r\n  page\r\n}\r\n\r\nexport default {\r\n  reBrand,\r\n  component,\r\n  store,\r\n  page\r\n}\r\n","/**\r\n * creates a Promise who does nothing and will be resolved in x milliseconds\r\n * @param {Number} delay - time in milliseconds to suspend the current process.\r\n * @returns {Promise}\r\n */\r\nconst sleep = function (delay) {\r\n  return new Promise(function (resolve) {\r\n    setTimeout(resolve, delay)\r\n  })\r\n}\r\n\r\nexport {\r\n  sleep\r\n}\r\n\r\nexport default {\r\n  sleep\r\n}\r\n","import factory from './factory'\r\nimport store from './store'\r\nimport uuid from './uuid'\r\nimport timer from './timer'\r\n\r\nexport { factory, store, uuid, timer }\r\nexport default { factory, store, uuid, timer }\r\n"],"sourceRoot":""}