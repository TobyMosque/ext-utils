module.exports=function(e){var c={};function t(l){if(c[l])return c[l].exports;var n=c[l]={i:l,l:!1,exports:{}};return e[l].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=e,t.c=c,t.d=function(e,c,l){t.o(e,c)||Object.defineProperty(e,c,{enumerable:!0,get:l})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,c){if(1&c&&(e=t(e)),8&c)return e;if(4&c&&"object"==typeof e&&e&&e.__esModule)return e;var l=Object.create(null);if(t.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:e}),2&c&&"string"!=typeof e)for(var n in e)t.d(l,n,function(c){return e[c]}.bind(null,n));return l},t.n=function(e){var c=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(c,"a",c),c},t.o=function(e,c){return Object.prototype.hasOwnProperty.call(e,c)},t.p="",t(t.s=2)}([function(module,exports){eval('module.exports = require("vue");\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInZ1ZVwiPzY2MzAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidnVlXCIpOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports){eval('module.exports = require("quasar");\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInF1YXNhclwiPzIxM2UiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicXVhc2FyXCIpOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(e,c,t){e.exports=t(3)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"factory\", function() { return /* reexport */ factory; });\n__webpack_require__.d(__webpack_exports__, \"store\", function() { return /* reexport */ src_store; });\n__webpack_require__.d(__webpack_exports__, \"uuid\", function() { return /* reexport */ src_uuid; });\n__webpack_require__.d(__webpack_exports__, \"timer\", function() { return /* reexport */ timer; });\n\n// EXTERNAL MODULE: external \"vue\"\nvar external_vue_ = __webpack_require__(0);\nvar external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);\n\n// CONCATENATED MODULE: ./src/_common.js\nconst getCases = function (text) {\r\n  let cases = {}\r\n  if (text.includes('-')) {\r\n    cases.lower = text.toLowerCase()\r\n    cases.camel = cases.lower.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });\r\n    cases.pascal = cases.camel[0].toUpperCase() + cases.camel.substr(1)\r\n  } else {\r\n    cases.camel = text[0].toLowerCase() + text.substr(1)\r\n    cases.pascal = text[0].toUpperCase() + text.substr(1)\r\n  }\r\n  return cases\r\n}\r\n\r\n\r\n\r\n/* harmony default export */ var _common = ({\r\n  getCases\r\n});\r\n\n// CONCATENATED MODULE: ./src/store.js\n\r\n\r\n\r\nconst store_defaultPrefixes = {\r\n  upsertPrefix: 'saveOrUpdate',\r\n  deletePrefix: 'delete'\r\n}\r\n\r\nconst getCollectionPrefixes = function () {\r\n  return store_defaultPrefixes\r\n}\r\n\r\nconst setCollectionPrefixes = function ({ upsertPrefix, deletePrefix }) {\r\n  store_defaultPrefixes.upsertPrefix = upsertPrefix || store_defaultPrefixes.upsertPrefix\r\n  store_defaultPrefixes.deletePrefix = deletePrefix || store_defaultPrefixes.deletePrefix\r\n}\r\n\r\n/**\r\n * maps all fields to a computed-like object who getters access the state and the setters do mutations.\r\n * @param {String} module - the module name\r\n * @param {String[] | Object} fields - fields can be an array of strings or a object where the keys and values are strings. e.g:` ['text', 'number', 'list']` or `{ text: 'text', number: 'number', collection: 'list' }`\r\n * @returns {Object} \r\n */\r\nconst mapState = function (module, fields) {\r\n  var props = {}\r\n  if (Array.isArray(fields)) {\r\n    fields.forEach(property => {\r\n      props[property] = {\r\n        get () {\r\n          return this.$store.state[module][property]\r\n        },\r\n        set (value) {\r\n          this.$store.commit(`${module}/${property}`, value)\r\n        }\r\n      }\r\n    })\r\n  } else {\r\n    Object.keys(fields).forEach(key => {\r\n      var property = fields[key]\r\n      props[key] = {\r\n        get () { return this.$store.state[module][property] },\r\n        set (value) { this.$store.commit(`${module}/${property}`, value) }\r\n      }\r\n    })\r\n  }\r\n  return props\r\n}\r\n\r\n/**\r\n * maps all fields to a computed-like object who getters access the getters and the setters do mutations.\r\n * @param {String} module - the module name\r\n * @param {String[] | Object} fields - fields can be an array of strings or a object where the keys and values are strings. e.g:` ['text', 'number', 'list']` or `{ text: 'text', number: 'number', collection: 'list' }`\r\n * @returns {Object} \r\n */\r\nconst mapGetters = function (module, fields) {\r\n  let props = {}\r\n  if (Array.isArray(fields)) {\r\n    fields.forEach(property => {\r\n      props[property] = {\r\n        get () {\r\n          return this.$store.getters[`${module}/${property}`]\r\n        },\r\n        set (value) {\r\n          this.$store.commit(`${module}/${property}`, value)\r\n        }\r\n      }\r\n    })\r\n  } else {\r\n    Object.keys(fields).forEach(key => {\r\n      let property = fields[key]\r\n      props[key] = {\r\n        get () { return this.$store.getters[`${module}/${property}`] },\r\n        set (value) { this.$store.commit(`${module}/${property}`, value) }\r\n      }\r\n    })\r\n  }\r\n  return props\r\n}\r\n\r\n/**\r\n * maps all classes fields to a mutations-like object.\r\n * @param {*} Model - class used to model the mutations object \r\n * @returns {Object} a object with the mapped mutations\r\n */\r\nconst mapStoreMutations = function (Model) {\r\n  const keys = Object.keys(new Model())\r\n  const mutations = keys.reduce((mutations, key) => {\r\n    mutations[key] = function (state, value) {\r\n      external_vue_default.a.set(state, key, value)\r\n    }\r\n    return mutations\r\n  }, {})\r\n  return mutations\r\n}\r\n\r\n/**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} CollectionItem\r\n * @property {String} single - the single form of the collection (item, person, job)\r\n * @property {String} plural - the plural form of the collection (list, people, jobs), would be the same as in the state\r\n * @property {String} id - the name of the id field of the object in the collection\r\n * @property {Object} type - the type of the objects in the array\r\n * @property {String} [upsertPrefix='saveOrUpdate'] - prefix of the save or update action\r\n * @property {String} [deletePrefix='delete'] - prefix of the delete action\r\n */\r\n\r\n/**\r\n * Create `mutations` (create, update, delete, setters), `actions` (upsert, delete, setters) and `getters` (index, getById) related to array fields.\r\n * @param {CollectionItem[]} collections - an array of objects that describes your collection\r\n * @returns {Object} a object with the mapped mutations, actions and getters\r\n */\r\nconst mapStoreCollections = function (collections) {\r\n  let mutations = {}\r\n  let actions = {}\r\n  let getters = {}\r\n  let hasTypes = collections.some(collection => collection.type !== void 0)\r\n  if (hasTypes) {\r\n    mutations.setPropertyOfACollectionItem = function (state, { index, collection, property, value }) {\r\n      external_vue_default.a.set(state[collection][index], property, value)\r\n    }\r\n    actions.setPropertyOfACollectionItem = function ({ commit, getters }, { id, collection, property, value }) {\r\n      const index = getters[collection + 'Index'].get(id)\r\n      if (index !== undefined) {\r\n        commit('setPropertyOfACollectionItem', { index, collection, property, value })\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let collection of collections) {\r\n    let single = getCases(collection.single)\r\n    let plural = getCases(collection.plural)\r\n\r\n    mutations[`create${single.pascal}`] = function (state, item) {\r\n      state[collection.plural].push(item)\r\n    }\r\n    mutations[`update${single.pascal}`] = function (state, { index, item }) {\r\n      external_vue_default.a.set(state[collection.plural], index, item)\r\n    }\r\n    mutations[`delete${single.pascal}`] = function (state, index) {\r\n      external_vue_default.a.delete(state[collection.plural], index)\r\n    }\r\n\r\n    let upsertPrefix = collection.upsertPrefix || store_defaultPrefixes.upsertPrefix\r\n    let deletePrefix = collection.deletePrefix || store_defaultPrefixes.deletePrefix\r\n    actions[`${upsertPrefix}${single.pascal}`] = function ({ commit, getters }, item) {\r\n      let index = getters[`${plural.camel}Index`].get(item[collection.id])\r\n      if (index !== void 0) {\r\n        commit(`update${single.pascal}`, { index, item })\r\n      } else {\r\n        commit(`create${single.pascal}`, item)\r\n      }\r\n    }\r\n    actions[`${deletePrefix}${single.pascal}`] = function ({ commit, getters }, id) { \r\n      let index = getters[`${plural.camel}Index`].get(id)\r\n      if (index !== void 0) {\r\n        commit(`delete${single.pascal}`, index)\r\n      }\r\n    }\r\n\r\n    if (collection.type !== void 0) {\r\n      let properties = Object.keys(new collection.type())\r\n      for (const property of properties) {\r\n        const names = getCases(property)\r\n        let conjunction = single.pascal.match(/^[aeiou].*/i) ? 'An' : 'A'\r\n        actions[`set${names.pascal}Of${conjunction}${single.pascal}`] = function ({ dispatch }, { id, value }) {\r\n          return dispatch('setPropertyOfACollectionItem', { id, collection: collection.plural, property, value })\r\n        }\r\n      }\r\n    }\r\n\r\n    getters[`${plural.camel}Index`] = function (state) {\r\n      let _collection = state[collection.plural] || []\r\n      return _collection.reduce((map, item, indice) => {\r\n        map.set(item[collection.id], indice)\r\n        return map\r\n      }, new Map())\r\n    }\r\n    getters[`${single.camel}ById`] = function (state, getters) {\r\n      return (id) => {\r\n        let index = getters[`${plural.camel}Index`].get(id)\r\n        return index !== void 0 ? state[collection.plural][index] : null\r\n      }\r\n    }\r\n  }\r\n  \r\n  return {\r\n    mutations,\r\n    actions,\r\n    getters\r\n  }\r\n}\r\n\r\n /**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} ComplexType\r\n * @property {String} name - the name of the field\r\n * @property {Object} type - the type of the object\r\n */\r\n\r\n/**\r\n * Create `mutations` (setters) related to complex fields.\r\n * @param {ComplexType[]} complexTypes - an array of objects that describes your collection\r\n * @returns {Object} a object with the mapped mutations\r\n */\r\nconst mapStoreComplexTypes = function (complexTypes) {\r\n  let mutations = {}\r\n  for (let complexType of complexTypes) {\r\n    let properties = Object.keys(new complexType.type())\r\n    let typeName = getCases(complexType.name)\r\n    for (const property of properties) {\r\n      const name = getCases(property)\r\n      mutations[`set${name.pascal}Of${typeName.pascal}`] = function (state, value) {\r\n        external_vue_default.a.set(state[complexType.name], property, value)\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    mutations\r\n  }\r\n}\r\n\r\n/**\r\n * Create `mutations` (setters) related to complex fields.\r\n * @param {String} module - the module name\r\n * @param {CollectionItem} params - an array of objects that describes your collection\r\n * @returns {Object} a object with the mapped mutations\r\n */\r\nconst mapCollectionItemState = function (module, { id, single, type, upsertPrefix }) {\r\n  let moduleName = module\r\n  let setModuleName = function (name) {\r\n    moduleName = name\r\n  }\r\n  let name = getCases(single)\r\n  let computed = {}\r\n\r\n  let getEntityById = `${name.camel}ById`\r\n  let entityName = `__${single}`\r\n  computed[getEntityById] = function () {\r\n    return this.$store.getters[`${moduleName}/${getEntityById}`]\r\n  }\r\n  computed[entityName] = function () {\r\n    return this[getEntityById](this[id])\r\n  }\r\n\r\n  let properties = Object.keys(new type())\r\n  for (const property of properties) {\r\n    const propName = getCases(property)\r\n    let conjunction = name.camel.match(/^[aeiou].*/i) ? 'An' : 'A'\r\n    let actionName = `set${propName.pascal}Of${conjunction}${name.pascal}`\r\n    computed[property] = {\r\n      get () {\r\n        return this[entityName][property]\r\n      },\r\n      set (value) {\r\n        this.$store.dispatch(`${moduleName}/${actionName}`, { id: this[id], value })\r\n      }\r\n    }\r\n  }\r\n\r\n  upsertPrefix = upsertPrefix || store_defaultPrefixes.upsertPrefix\r\n  computed[single] = {\r\n    get () {\r\n      let entity = {}\r\n      let scope = this\r\n      for (const property of properties) {\r\n        Object.defineProperty(entity, property, {\r\n          get () { return scope[property] },\r\n          set (value) { scope[property] = value }\r\n        })\r\n      }\r\n      return entity\r\n    },\r\n    set (value) {\r\n      let upsertAction = `${moduleName}/${upsertPrefix}${name.pascal}`\r\n      this.$store.dispatch(upsertAction, value)\r\n    }\r\n  }\r\n\r\n  return {\r\n    setModuleName,\r\n    computed\r\n  }\r\n}\r\n\r\n/**\r\n * Create `mutations` (setters) related to complex fields.\r\n * @param {String} module - the module name\r\n * @param {ComplexType} params - an array of objects that describes your collection\r\n * @returns {Object} a object with the mapped mutations\r\n */\r\nconst mapComplexTypeState = function (module, { name, type }) {\r\n  let moduleName = module\r\n  let setModuleName = function (name) {\r\n    moduleName = name\r\n  }\r\n  let single = getCases(name)\r\n  let computed = {}\r\n\r\n  let properties = Object.keys(new type())\r\n  for (const property of properties) {\r\n    const propName = getCases(property)\r\n    let actionName = `set${propName.pascal}Of${single.pascal}`\r\n    computed[property] = {\r\n      get () {\r\n        return this.$store.state[moduleName][name][property]\r\n      },\r\n      set (value) {\r\n        this.$store.commit(`${moduleName}/${actionName}`, value)\r\n      }\r\n    }\r\n  }\r\n\r\n  computed[name] = {\r\n    get () {\r\n      let entity = {}\r\n      let scope = this\r\n      for (const property of properties) {\r\n        Object.defineProperty(entity, property, {\r\n          get () { return scope[property] },\r\n          set (value) { scope[property] = value }\r\n        })\r\n      }\r\n      return entity\r\n    },\r\n    set (value) {\r\n      this.$store.commit(`${moduleName}/${name}`, value)\r\n    }\r\n  }\r\n\r\n  return {\r\n    setModuleName,\r\n    computed\r\n  }\r\n}\r\n\r\n\r\n\r\n/* harmony default export */ var src_store = ({\r\n  getCollectionPrefixes,\r\n  setCollectionPrefixes,\r\n  mapState,\r\n  mapGetters,\r\n  mapStoreMutations,\r\n  mapStoreCollections,\r\n  mapStoreComplexTypes,\r\n  mapCollectionItemState,\r\n  mapComplexTypeState\r\n});\r\n\n// EXTERNAL MODULE: external \"quasar\"\nvar external_quasar_ = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/uuid.js\n\r\n\r\n/**\r\n * creates a comb (combined time-uuid)\r\n * @param {*} date - date used to create the COMB\r\n * @returns {String} returns a combined time-uuid (comb)\r\n */\r\nconst uuid_comb = function (date) {\r\n  if (!date) {\r\n    date = new Date()\r\n  }\r\n  let uuid = Object(external_quasar_[\"uid\"])()\r\n  let comb = ('00000000000' + date.getTime().toString(16)).substr(-12)\r\n  comb = comb.slice(0, 8) + '-' + comb.slice(8, 12)\r\n  return uuid.replace(uuid.slice(0, 13), comb)\r\n}\r\n\r\n/**\r\n * extract the date part of the comb\r\n * @param {String} comb a combined time-uuid (comb)\r\n * @returns {Date} the date part of the comb\r\n */\r\nconst extract = function (comb) {\r\n  let text = comb.replace(/-/g, '').substr(0, 12)\r\n  let time = parseInt(text, 16)\r\n  return new Date(time)\r\n}\r\n\r\n\r\n\r\n/* harmony default export */ var src_uuid = ({\r\n  comb: uuid_comb,\r\n  extract\r\n});\r\n\n// CONCATENATED MODULE: ./src/factory.js\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} ComponentFactory\r\n * @param {Function} render - callback function that is called everytime the component is rendered: render ({ self, options }) { }\r\n * @param {Function} setup - callback function that is called when the component is ready to be returned: setup({ component }) { }\r\n */\r\n\r\n /**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} CollectionItem\r\n * @property {String} single - the single form of the collection (item, person, job)\r\n * @property {String} plural - the plural form of the collection (list, people, jobs), would be the same as in the state\r\n * @property {String} id - the name of the id field of the object in the collection\r\n * @property {Object} type - the type of the objects in the array\r\n * @property {String} [upsertPrefix='saveOrUpdate'] - prefix of the save or update action\r\n * @property {String} [deletePrefix='delete'] - prefix of the delete action\r\n */\r\n\r\n /**\r\n * The complete Triforce, or one or more components of the Triforce.\r\n * @typedef {Object} ComplexType\r\n * @property {String} name - the name of the field\r\n * @property {Object} type - the type of the object\r\n */\r\n\r\n/**\r\n * wrapper a component and allow them to be modified at the render time, or even setup your properties, slots, etc.\r\n * @param {Object} param\r\n * @param {String} param.name - component's name\r\n * @param {Object} param.component - component to be wrapped\r\n * @param {Function} param.render - callback function that is called everytime the component is rendered: render ({ self, options }) { }\r\n * @param {Function} param.setup - callback function that is called when the component is ready to be returned: setup({ component }) { }\r\n * @param {Function} [param.createElement=function (h, component, options) {\r\n     return h(component, options)\r\n   }]\r\n * @param {ComponentFactory[]} param.factories - array of objects with a render and/or setup field\r\n */\r\nconst factory_component = function ({ name, component, render, setup, createElement, factories }) {\r\n  const props = component.options.props\r\n  const computed = {}\r\n  if (props.value) {\r\n    computed.__value = {\r\n      get () { return this.value },\r\n      set (value) { return this.$emit('input', value) }\r\n    }\r\n  }\r\n  const methods = Object.keys(component.options.methods || {}).reduce((methods, key) => {\r\n    methods[key] = function (...args) {\r\n      let root = this.$refs.root\r\n      return root[key].apply(root, args)\r\n    }\r\n    return methods\r\n  }, {})\r\n\r\n  factories = factories || []\r\n  const renders = factories.filter(item => item.render).map(item => item.render)\r\n  if (render) {\r\n    renders.push(render)\r\n  }\r\n\r\n  const setups = factories.filter(item => item.setup).map(item => item.setup)\r\n  if (setup) {\r\n    setups.push(setup)\r\n  }\r\n\r\n  if (!createElement) {\r\n    createElement = function (h, component, options) {\r\n      return h(component, options)\r\n    }\r\n  }\r\n  let wrapper = {\r\n    name: name,\r\n    props: props,\r\n    methods: methods,\r\n    computed: computed,\r\n    render (h) {\r\n      let self = this\r\n      let key = this.$vnode.key\r\n      let options = {\r\n        key: key,\r\n        ref: 'root',\r\n        scopedSlots: this.$scopedSlots,\r\n        attrs: this.$attrs\r\n      }\r\n      if (props.value) {\r\n        let { values, ...props } = this.$props\r\n        let { input, ...listeners } = this.$listeners\r\n        props.value = self.__value\r\n        listeners.input = function (value) {\r\n          self.__value = value\r\n        }\r\n        options.props = props\r\n        options.on = listeners\r\n      } else {\r\n        let { ...props } = this.$props\r\n        let { ...listeners } = this.$listeners\r\n        options.props = props\r\n        options.on = listeners\r\n      }\r\n\r\n      for (let render of renders) {\r\n        render({ self, options })\r\n      }\r\n      return createElement(h, component, options)\r\n    }\r\n  }\r\n  for (let setup of setups) {\r\n    setup({ component: wrapper })\r\n  }\r\n  return wrapper\r\n}\r\n\r\nconst __component = factory_component\r\n\r\n/**\r\n * @param {String|Object} options\r\n * @param {Object} component\r\n * @param {Object} brand\r\n * @param {String|Object|Array} brand.style\r\n * @param {String|Object|Array} brand.class\r\n * @param {Object} brand.props\r\n */\r\nconst reBrand = function (options, component, brand) {\r\n  let name = '', cname = '', register = null\r\n  if (typeof options === 'object') {\r\n    name = options.name\r\n    cname = options.cname\r\n    component = options.component\r\n    brand = options.brand\r\n    register = options.register\r\n  } else {\r\n    name = options\r\n  }\r\n  if (!cname) {\r\n    cname = getCases(name).pascal\r\n  }\r\n  if (!register) {\r\n    register = function (name, component) {\r\n      external_vue_default.a.component(name, component)\r\n    }\r\n  }\r\n\r\n  var keys = Object.keys(brand.props || {})\r\n  register(name, __component({\r\n    name: cname || component.name,\r\n    component,\r\n    render ({ self, options }) {\r\n      if (brand.style) {\r\n        options.style = brand.style\r\n      }\r\n      if (brand.class) {\r\n        options.class = brand.class\r\n      }\r\n      for (const prop of keys) {\r\n        options.props[prop] = options.props[prop] === undefined ? brand.props[prop] : options.props[prop]\r\n      }\r\n      return null\r\n    },\r\n    setup ({ component }) {\r\n      for (const prop of keys) {\r\n        component.props[prop].default = () => undefined\r\n      }\r\n    }\r\n  }))\r\n}\r\n\r\nconst merge = function ({ name, model, collections, complexTypes, user }) {\r\n  let conditions = [\r\n    model && model[name],\r\n    collections && collections[name],\r\n    !!user\r\n  ].filter(condition => condition)\r\n\r\n  if (conditions.length > 1) {\r\n    let merged = {}\r\n    let isFunc = false\r\n    if (user) {\r\n      isFunc = isFunc || user.call\r\n      merged = user.call ? { ...merged, ...user() } : { ...merged, ...user }\r\n    }\r\n    if (model && model[name]) {\r\n      isFunc = isFunc || model[name].call\r\n      merged = model[name].call ? { ...merged, ...model[name]() } : { ...merged, ...model[name] }\r\n    }\r\n    if (collections && collections[name]) {\r\n      isFunc = isFunc || collections[name].call\r\n      merged = collections[name].call ? { ...merged, ...collections[name]() } : { ...merged, ...collections[name] }\r\n    }\r\n    if (complexTypes && complexTypes[name]) {\r\n      isFunc = isFunc || complexTypes[name].call\r\n      merged = complexTypes[name].call ? { ...merged, ...complexTypes[name]() } : { ...merged, ...complexTypes[name] }\r\n    }\r\n    if (isFunc) {\r\n      let __merged = merged\r\n      merged = function () {\r\n        return JSON.parse(JSON.stringify(__merged))\r\n      }\r\n    }\r\n    return merged\r\n  } else if (model && model[name]) {\r\n    return model[name]\r\n  } else if (collections && collections[name]) {\r\n    return collections[name]\r\n  } else if (complexTypes && complexTypes[name]) {\r\n    return complexTypes[name]\r\n  } else {\r\n    return user\r\n  }\r\n}\r\n\r\nconst preperValidation = function ({ store, fields }) {\r\n  store.mutations = store.mutations || {}\r\n  const fieldKeys = Object.keys(fields)\r\n  for (const field of fieldKeys) {\r\n    store.mutations[field] = function (state, value) { state[field] = value }\r\n  }\r\n  \r\n  store.state = store.state || {}\r\n  let isFunc = !!store.state.call\r\n  if (isFunc) {\r\n    store.state = store.state()\r\n  }\r\n  for (const field of fieldKeys) {\r\n    store.state[field] = fields[field]\r\n  }\r\n  if (isFunc) {\r\n    let obj = store.state\r\n    store.state = function () {\r\n      return { ...obj }\r\n    }\r\n  }\r\n}\r\n\r\nconst validationField = '@@'\r\nconst fetchedField = '@tmu_fetched'\r\n/**\r\n * factory.store combines store.mapStoreMutations and store.mapStoreCollections.\r\n * @param {Object} param - the page properties (`created`, `computed`, `etc`)\r\n * @param {Object} param.options - options used to generate the page\r\n * @param {Object} param.options.model - class used to model the mutations object\r\n * @param {CollectionItem[]} param.options.collections - an array of objects that describes your collection\r\n * @param {ComplexType[]} param.options.collections - an array of objects that describes your collection\r\n * @param {String} param.state - module's state, that will be merged intro the final module\r\n * @param {String} param.mutations - module's mutations, that will be merged intro the final module\r\n * @param {String} param.actions - module's actions, that will be merged intro the final module\r\n * @param {String} param.getters - module's getters, that will be merged intro the final module\r\n */\r\nconst factory_store = function ({ options, initialize, ...store }) {\r\n  let model, collections, complexTypes\r\n  if (options && options.model) {\r\n    model = {\r\n      state: function () {\r\n        return new options.model()\r\n      },\r\n      mutations: mapStoreMutations(options.model)\r\n    }\r\n  }\r\n  if (options && options.collections && options.collections.length > 0) {\r\n    collections = mapStoreCollections(options.collections)\r\n  }\r\n  if (options && options.complexTypes && options.complexTypes.length > 0) {\r\n    complexTypes = mapStoreComplexTypes(options.complexTypes)\r\n  }\r\n\r\n  preperValidation({ store, fields: { [validationField]: 0, [fetchedField]: false } })\r\n  store.namespaced = true\r\n  store.state = merge({ name: 'state', model, collections, complexTypes,  user: store.state })\r\n  store.mutations = merge({ name: 'mutations', model, collections, complexTypes, user: store.mutations }) || {}\r\n  store.actions = merge({ name: 'actions', model, collections, complexTypes, user: store.actions }) || {}\r\n  store.getters = merge({ name: 'getters', model, collections, complexTypes, user: store.getters })\r\n  if (!store.actions.initialize) {\r\n    store.actions.initialize = initialize || function (context, values) {}\r\n  }\r\n  return store\r\n}\r\n\r\n/**\r\n * factory.page will expect the same options as factory.store and will map the state, mutations, actions and getters generated by factory.store to the page.\r\n * @param {Object} param - the page properties (`created`, `computed`, `etc`)\r\n * @param {Object} param.options - options used to generate the page\r\n * @param {Object} param.options.model - class used to model the mutations object\r\n * @param {CollectionItem[]} param.options.collections - an array of objects that describes your collection\r\n * @param {Object} param.storeModule - if not null, it'll be registered in the preFetch or in the created hook, and removed in the destroyed hook.\r\n * @param {String} param.moduleName - the prefix of the private fields used by the getters and setters\r\n */\r\nconst factory_page = function ({ options, storeModule, moduleName, ...page }) {\r\n  let { preFetch, created, mounted, destroyed } = page\r\n\r\n  const checkModule = function ({ store, success, failure }) {\r\n    if (storeModule.mutations[validationField]) {\r\n      let comb = src_uuid.comb()\r\n      let mutationName = `${moduleName}/${validationField}`\r\n      if (store.state[moduleName] && store._mutations[mutationName]) {\r\n        store.commit(mutationName, comb)\r\n        let value = (store.state[moduleName] || {})[validationField]\r\n        if (value === comb) {\r\n          if (success) success()\r\n        } else {\r\n          if (failure) failure()\r\n        }\r\n      } else if (failure) {\r\n        failure()\r\n      }\r\n    }\r\n  }\r\n\r\n  if (storeModule) {\r\n    page.preFetch = function (context) {\r\n      let self = this\r\n      let { store, currentRoute, previousRoute, redirect } = context\r\n      checkModule({\r\n        store,\r\n        success () {\r\n          store.unregisterModule(moduleName)\r\n        }\r\n      })\r\n      store.registerModule(moduleName, storeModule)\r\n      let fetched = store.state[moduleName] && store.state[moduleName][fetchedField]\r\n      if (!fetched) {\r\n        fetched = store.dispatch(`${moduleName}/initialize`, {\r\n          route: currentRoute,\r\n          from: previousRoute,\r\n          next: redirect\r\n        }).finally(function () {\r\n          store.commit(`${moduleName}/${fetchedField}`, true)\r\n        })\r\n        store.commit(`${moduleName}/${fetchedField}`, fetched)\r\n      }\r\n      if (!fetched.then) {\r\n        fetched = Promise.resolve()\r\n      }\r\n      return fetched.then(function () {\r\n        if (preFetch) {\r\n          return preFetch.apply(self, [ context ])\r\n        }\r\n      })\r\n    }\r\n  \r\n    page.created = function () {\r\n      let self = this\r\n      let fetched  = this.$store.state[moduleName] && this.$store.state[moduleName][fetchedField]\r\n      checkModule({\r\n        store: this.$store,\r\n        failure () {\r\n          self.$store.registerModule(moduleName, storeModule, { preserveState: fetched === true })\r\n        }\r\n      })\r\n      if (created) {\r\n        created.apply(self, [])\r\n      }\r\n    }\r\n\r\n    page.mounted = function () {\r\n      let self = this\r\n      let fetched  = this.$store.state[moduleName] && this.$store.state[moduleName][fetchedField]\r\n      if (!fetched) {\r\n        const args = this.$route ? {\r\n          route: this.$route,\r\n          next: this.$router.replace.bind(this.$router)\r\n        } : undefined\r\n\r\n        fetched = this.$store.dispatch(`${moduleName}/initialize`, args).finally(function () {\r\n          self.$store.commit(`${moduleName}/${fetchedField}`, true)\r\n        })\r\n        this.$store.commit(`${moduleName}/${fetchedField}`, fetched)\r\n      }\r\n      if (mounted) {\r\n        mounted.apply(self, [])\r\n      }\r\n    }\r\n  \r\n    page.destroyed = function () {\r\n      let self = this\r\n      if (destroyed) {\r\n        destroyed.apply(self, [])\r\n      }\r\n      checkModule({\r\n        store: this.$store,\r\n        success () {\r\n          self.$store.unregisterModule(moduleName)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  if (options && options.model) {\r\n    let keys = Object.keys(new options.model())\r\n    page.computed = {\r\n      ...page.computed,\r\n      ...mapState(moduleName, keys)\r\n    }\r\n  }\r\n\r\n  if (options && options.collections) {\r\n    let actions = {}\r\n    let getters = {}\r\n    let defaultPrefixes = getCollectionPrefixes()\r\n    let hasTypes = options.collections.some(collection => collection.type !== void 0)\r\n    if (hasTypes) {\r\n      actions.setPropertyOfACollectionItem = function ({ id, collection, property, value }) {\r\n        return this.$store.dispatch(`${moduleName}/setPropertyOfACollectionItem`, { id, collection, property, value })\r\n      }\r\n    }\r\n\r\n    for (let collection of options.collections) {\r\n      let single = getCases(collection.single)\r\n      let plural = getCases(collection.plural)\r\n      let upsertPrefix = collection.upsertPrefix || defaultPrefixes.upsertPrefix\r\n      let deletePrefix = collection.deletePrefix || defaultPrefixes.deletePrefix\r\n      actions[`${upsertPrefix}${single.pascal}`] = function (item) {\r\n        return this.$store.dispatch(`${moduleName}/${upsertPrefix}${single.pascal}`, item)\r\n      }\r\n      actions[`${deletePrefix}${single.pascal}`] = function (id) {\r\n        return this.$store.dispatch(`${moduleName}/${deletePrefix}${single.pascal}`, id)\r\n      }\r\n      getters[`${plural.camel}Index`] = function () {\r\n        let getter = this.$store.getters[`${moduleName}/${moduleName}/${plural.camel}Index`]\r\n        if (getter) {\r\n          return getter\r\n        } else {\r\n          let state = this.$store.state[moduleName]\r\n          return storeModule.getters[`${plural.camel}Index`](state, this)\r\n        }\r\n      }\r\n      getters[`${single.camel}ById`] = function () {\r\n        let getter = this.$store.getters[`${moduleName}/${single.camel}ById`]\r\n        if (getter) {\r\n          return getter\r\n        } else {\r\n          let state = this.$store.state[moduleName]\r\n          return storeModule.getters[`${single.camel}ById`](state, this)\r\n        }\r\n      }\r\n      if (collection.type !== void 0) {\r\n        let properties = Object.keys(new collection.type())\r\n        for (const property of properties) {\r\n          let name = getCases(property)\r\n          let conjunction = single.pascal.match(/^[aeiou].*/i) ? 'An' : 'A'\r\n          let actionName = `set${name.pascal}Of${conjunction}${single.pascal}`\r\n          actions[actionName] = function ({ id, value }) {\r\n            return this.$store.dispatch(`${moduleName}/${actionName}`, { id, collection: collection.plural, property, value })\r\n          }\r\n        }\r\n      }\r\n    }\r\n    page.computed = {\r\n      ...page.computed,\r\n      ...getters\r\n    }\r\n    page.methods = {\r\n      ...page.methods,\r\n      ...actions\r\n    }\r\n  }\r\n  if (options && options.complexTypes) {\r\n    let getters = {}\r\n    for (let complexType of options.complexTypes) {\r\n      let properties = Object.keys(new complexType.type())\r\n      let typeName = getCases(complexType.name)\r\n      for (const property of properties) {\r\n        const name = getCases(property)\r\n        const camelName = `${name.camel}Of${typeName.pascal}`\r\n        const pascalName = `set${name.pascal}Of${typeName.pascal}`\r\n        getters[camelName] = {\r\n          get () {\r\n            return this.$store.state[moduleName][complexType.name][property]\r\n          },\r\n          set (value) {\r\n            this.$store.commit(`${moduleName}/${pascalName}`, value)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    page.computed = {\r\n      ...page.computed,\r\n      ...getters\r\n    }\r\n  }\r\n  return page\r\n}\r\n\r\n\r\n\r\n/* harmony default export */ var factory = ({\r\n  reBrand,\r\n  component: factory_component,\r\n  store: factory_store,\r\n  page: factory_page\r\n});\r\n\n// CONCATENATED MODULE: ./src/timer.js\n/**\r\n * creates a Promise who does nothing and will be resolved in x milliseconds\r\n * @param {Number} delay - time in milliseconds to suspend the current process.\r\n * @returns {Promise}\r\n */\r\nconst sleep = function (delay) {\r\n  return new Promise(function (resolve) {\r\n    setTimeout(resolve, delay)\r\n  })\r\n}\r\n\r\n\r\n\r\n/* harmony default export */ var timer = ({\r\n  sleep\r\n});\r\n\n// CONCATENATED MODULE: ./src/index.js\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ var src = __webpack_exports__[\"default\"] = ({ factory: factory, store: src_store, uuid: src_uuid, timer: timer });\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9fY29tbW9uLmpzP2NiNTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlLmpzP2MwZDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V1aWQuanM/ZWUwYiIsIndlYnBhY2s6Ly8vLi9zcmMvZmFjdG9yeS5qcz8wM2EwIiwid2VicGFjazovLy8uL3NyYy90aW1lci5qcz9hYjRiIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldENhc2VzID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICBsZXQgY2FzZXMgPSB7fVxyXG4gIGlmICh0ZXh0LmluY2x1ZGVzKCctJykpIHtcclxuICAgIGNhc2VzLmxvd2VyID0gdGV4dC50b0xvd2VyQ2FzZSgpXHJcbiAgICBjYXNlcy5jYW1lbCA9IGNhc2VzLmxvd2VyLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uIChnKSB7IHJldHVybiBnWzFdLnRvVXBwZXJDYXNlKCk7IH0pO1xyXG4gICAgY2FzZXMucGFzY2FsID0gY2FzZXMuY2FtZWxbMF0udG9VcHBlckNhc2UoKSArIGNhc2VzLmNhbWVsLnN1YnN0cigxKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjYXNlcy5jYW1lbCA9IHRleHRbMF0udG9Mb3dlckNhc2UoKSArIHRleHQuc3Vic3RyKDEpXHJcbiAgICBjYXNlcy5wYXNjYWwgPSB0ZXh0WzBdLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnN1YnN0cigxKVxyXG4gIH1cclxuICByZXR1cm4gY2FzZXNcclxufVxyXG5cclxuZXhwb3J0IHtcclxuICBnZXRDYXNlc1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgZ2V0Q2FzZXNcclxufVxyXG4iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IHsgZ2V0Q2FzZXMgfSBmcm9tICcuL19jb21tb24nXHJcblxyXG5jb25zdCBkZWZhdWx0UHJlZml4ZXMgPSB7XHJcbiAgdXBzZXJ0UHJlZml4OiAnc2F2ZU9yVXBkYXRlJyxcclxuICBkZWxldGVQcmVmaXg6ICdkZWxldGUnXHJcbn1cclxuXHJcbmNvbnN0IGdldENvbGxlY3Rpb25QcmVmaXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZGVmYXVsdFByZWZpeGVzXHJcbn1cclxuXHJcbmNvbnN0IHNldENvbGxlY3Rpb25QcmVmaXhlcyA9IGZ1bmN0aW9uICh7IHVwc2VydFByZWZpeCwgZGVsZXRlUHJlZml4IH0pIHtcclxuICBkZWZhdWx0UHJlZml4ZXMudXBzZXJ0UHJlZml4ID0gdXBzZXJ0UHJlZml4IHx8IGRlZmF1bHRQcmVmaXhlcy51cHNlcnRQcmVmaXhcclxuICBkZWZhdWx0UHJlZml4ZXMuZGVsZXRlUHJlZml4ID0gZGVsZXRlUHJlZml4IHx8IGRlZmF1bHRQcmVmaXhlcy5kZWxldGVQcmVmaXhcclxufVxyXG5cclxuLyoqXHJcbiAqIG1hcHMgYWxsIGZpZWxkcyB0byBhIGNvbXB1dGVkLWxpa2Ugb2JqZWN0IHdobyBnZXR0ZXJzIGFjY2VzcyB0aGUgc3RhdGUgYW5kIHRoZSBzZXR0ZXJzIGRvIG11dGF0aW9ucy5cclxuICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZSAtIHRoZSBtb2R1bGUgbmFtZVxyXG4gKiBAcGFyYW0ge1N0cmluZ1tdIHwgT2JqZWN0fSBmaWVsZHMgLSBmaWVsZHMgY2FuIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgYSBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYW5kIHZhbHVlcyBhcmUgc3RyaW5ncy4gZS5nOmAgWyd0ZXh0JywgJ251bWJlcicsICdsaXN0J11gIG9yIGB7IHRleHQ6ICd0ZXh0JywgbnVtYmVyOiAnbnVtYmVyJywgY29sbGVjdGlvbjogJ2xpc3QnIH1gXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFxyXG4gKi9cclxuY29uc3QgbWFwU3RhdGUgPSBmdW5jdGlvbiAobW9kdWxlLCBmaWVsZHMpIHtcclxuICB2YXIgcHJvcHMgPSB7fVxyXG4gIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcclxuICAgIGZpZWxkcy5mb3JFYWNoKHByb3BlcnR5ID0+IHtcclxuICAgICAgcHJvcHNbcHJvcGVydHldID0ge1xyXG4gICAgICAgIGdldCAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuc3RhdGVbbW9kdWxlXVtwcm9wZXJ0eV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCAodmFsdWUpIHtcclxuICAgICAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdChgJHttb2R1bGV9LyR7cHJvcGVydHl9YCwgdmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH0gZWxzZSB7XHJcbiAgICBPYmplY3Qua2V5cyhmaWVsZHMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgdmFyIHByb3BlcnR5ID0gZmllbGRzW2tleV1cclxuICAgICAgcHJvcHNba2V5XSA9IHtcclxuICAgICAgICBnZXQgKCkgeyByZXR1cm4gdGhpcy4kc3RvcmUuc3RhdGVbbW9kdWxlXVtwcm9wZXJ0eV0gfSxcclxuICAgICAgICBzZXQgKHZhbHVlKSB7IHRoaXMuJHN0b3JlLmNvbW1pdChgJHttb2R1bGV9LyR7cHJvcGVydHl9YCwgdmFsdWUpIH1cclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbiAgcmV0dXJuIHByb3BzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBtYXBzIGFsbCBmaWVsZHMgdG8gYSBjb21wdXRlZC1saWtlIG9iamVjdCB3aG8gZ2V0dGVycyBhY2Nlc3MgdGhlIGdldHRlcnMgYW5kIHRoZSBzZXR0ZXJzIGRvIG11dGF0aW9ucy5cclxuICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZSAtIHRoZSBtb2R1bGUgbmFtZVxyXG4gKiBAcGFyYW0ge1N0cmluZ1tdIHwgT2JqZWN0fSBmaWVsZHMgLSBmaWVsZHMgY2FuIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgYSBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYW5kIHZhbHVlcyBhcmUgc3RyaW5ncy4gZS5nOmAgWyd0ZXh0JywgJ251bWJlcicsICdsaXN0J11gIG9yIGB7IHRleHQ6ICd0ZXh0JywgbnVtYmVyOiAnbnVtYmVyJywgY29sbGVjdGlvbjogJ2xpc3QnIH1gXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFxyXG4gKi9cclxuY29uc3QgbWFwR2V0dGVycyA9IGZ1bmN0aW9uIChtb2R1bGUsIGZpZWxkcykge1xyXG4gIGxldCBwcm9wcyA9IHt9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xyXG4gICAgZmllbGRzLmZvckVhY2gocHJvcGVydHkgPT4ge1xyXG4gICAgICBwcm9wc1twcm9wZXJ0eV0gPSB7XHJcbiAgICAgICAgZ2V0ICgpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzW2Ake21vZHVsZX0vJHtwcm9wZXJ0eX1gXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0ICh2YWx1ZSkge1xyXG4gICAgICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KGAke21vZHVsZX0vJHtwcm9wZXJ0eX1gLCB2YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfSBlbHNlIHtcclxuICAgIE9iamVjdC5rZXlzKGZpZWxkcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBsZXQgcHJvcGVydHkgPSBmaWVsZHNba2V5XVxyXG4gICAgICBwcm9wc1trZXldID0ge1xyXG4gICAgICAgIGdldCAoKSB7IHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzW2Ake21vZHVsZX0vJHtwcm9wZXJ0eX1gXSB9LFxyXG4gICAgICAgIHNldCAodmFsdWUpIHsgdGhpcy4kc3RvcmUuY29tbWl0KGAke21vZHVsZX0vJHtwcm9wZXJ0eX1gLCB2YWx1ZSkgfVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuICByZXR1cm4gcHJvcHNcclxufVxyXG5cclxuLyoqXHJcbiAqIG1hcHMgYWxsIGNsYXNzZXMgZmllbGRzIHRvIGEgbXV0YXRpb25zLWxpa2Ugb2JqZWN0LlxyXG4gKiBAcGFyYW0geyp9IE1vZGVsIC0gY2xhc3MgdXNlZCB0byBtb2RlbCB0aGUgbXV0YXRpb25zIG9iamVjdCBcclxuICogQHJldHVybnMge09iamVjdH0gYSBvYmplY3Qgd2l0aCB0aGUgbWFwcGVkIG11dGF0aW9uc1xyXG4gKi9cclxuY29uc3QgbWFwU3RvcmVNdXRhdGlvbnMgPSBmdW5jdGlvbiAoTW9kZWwpIHtcclxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmV3IE1vZGVsKCkpXHJcbiAgY29uc3QgbXV0YXRpb25zID0ga2V5cy5yZWR1Y2UoKG11dGF0aW9ucywga2V5KSA9PiB7XHJcbiAgICBtdXRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUpIHtcclxuICAgICAgVnVlLnNldChzdGF0ZSwga2V5LCB2YWx1ZSlcclxuICAgIH1cclxuICAgIHJldHVybiBtdXRhdGlvbnNcclxuICB9LCB7fSlcclxuICByZXR1cm4gbXV0YXRpb25zXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgY29tcGxldGUgVHJpZm9yY2UsIG9yIG9uZSBvciBtb3JlIGNvbXBvbmVudHMgb2YgdGhlIFRyaWZvcmNlLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xsZWN0aW9uSXRlbVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gc2luZ2xlIC0gdGhlIHNpbmdsZSBmb3JtIG9mIHRoZSBjb2xsZWN0aW9uIChpdGVtLCBwZXJzb24sIGpvYilcclxuICogQHByb3BlcnR5IHtTdHJpbmd9IHBsdXJhbCAtIHRoZSBwbHVyYWwgZm9ybSBvZiB0aGUgY29sbGVjdGlvbiAobGlzdCwgcGVvcGxlLCBqb2JzKSwgd291bGQgYmUgdGhlIHNhbWUgYXMgaW4gdGhlIHN0YXRlXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBpZCAtIHRoZSBuYW1lIG9mIHRoZSBpZCBmaWVsZCBvZiB0aGUgb2JqZWN0IGluIHRoZSBjb2xsZWN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0eXBlIC0gdGhlIHR5cGUgb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5XHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdXBzZXJ0UHJlZml4PSdzYXZlT3JVcGRhdGUnXSAtIHByZWZpeCBvZiB0aGUgc2F2ZSBvciB1cGRhdGUgYWN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZGVsZXRlUHJlZml4PSdkZWxldGUnXSAtIHByZWZpeCBvZiB0aGUgZGVsZXRlIGFjdGlvblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYG11dGF0aW9uc2AgKGNyZWF0ZSwgdXBkYXRlLCBkZWxldGUsIHNldHRlcnMpLCBgYWN0aW9uc2AgKHVwc2VydCwgZGVsZXRlLCBzZXR0ZXJzKSBhbmQgYGdldHRlcnNgIChpbmRleCwgZ2V0QnlJZCkgcmVsYXRlZCB0byBhcnJheSBmaWVsZHMuXHJcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbkl0ZW1bXX0gY29sbGVjdGlvbnMgLSBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgZGVzY3JpYmVzIHlvdXIgY29sbGVjdGlvblxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIG9iamVjdCB3aXRoIHRoZSBtYXBwZWQgbXV0YXRpb25zLCBhY3Rpb25zIGFuZCBnZXR0ZXJzXHJcbiAqL1xyXG5jb25zdCBtYXBTdG9yZUNvbGxlY3Rpb25zID0gZnVuY3Rpb24gKGNvbGxlY3Rpb25zKSB7XHJcbiAgbGV0IG11dGF0aW9ucyA9IHt9XHJcbiAgbGV0IGFjdGlvbnMgPSB7fVxyXG4gIGxldCBnZXR0ZXJzID0ge31cclxuICBsZXQgaGFzVHlwZXMgPSBjb2xsZWN0aW9ucy5zb21lKGNvbGxlY3Rpb24gPT4gY29sbGVjdGlvbi50eXBlICE9PSB2b2lkIDApXHJcbiAgaWYgKGhhc1R5cGVzKSB7XHJcbiAgICBtdXRhdGlvbnMuc2V0UHJvcGVydHlPZkFDb2xsZWN0aW9uSXRlbSA9IGZ1bmN0aW9uIChzdGF0ZSwgeyBpbmRleCwgY29sbGVjdGlvbiwgcHJvcGVydHksIHZhbHVlIH0pIHtcclxuICAgICAgVnVlLnNldChzdGF0ZVtjb2xsZWN0aW9uXVtpbmRleF0sIHByb3BlcnR5LCB2YWx1ZSlcclxuICAgIH1cclxuICAgIGFjdGlvbnMuc2V0UHJvcGVydHlPZkFDb2xsZWN0aW9uSXRlbSA9IGZ1bmN0aW9uICh7IGNvbW1pdCwgZ2V0dGVycyB9LCB7IGlkLCBjb2xsZWN0aW9uLCBwcm9wZXJ0eSwgdmFsdWUgfSkge1xyXG4gICAgICBjb25zdCBpbmRleCA9IGdldHRlcnNbY29sbGVjdGlvbiArICdJbmRleCddLmdldChpZClcclxuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb21taXQoJ3NldFByb3BlcnR5T2ZBQ29sbGVjdGlvbkl0ZW0nLCB7IGluZGV4LCBjb2xsZWN0aW9uLCBwcm9wZXJ0eSwgdmFsdWUgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgY29sbGVjdGlvbiBvZiBjb2xsZWN0aW9ucykge1xyXG4gICAgbGV0IHNpbmdsZSA9IGdldENhc2VzKGNvbGxlY3Rpb24uc2luZ2xlKVxyXG4gICAgbGV0IHBsdXJhbCA9IGdldENhc2VzKGNvbGxlY3Rpb24ucGx1cmFsKVxyXG5cclxuICAgIG11dGF0aW9uc1tgY3JlYXRlJHtzaW5nbGUucGFzY2FsfWBdID0gZnVuY3Rpb24gKHN0YXRlLCBpdGVtKSB7XHJcbiAgICAgIHN0YXRlW2NvbGxlY3Rpb24ucGx1cmFsXS5wdXNoKGl0ZW0pXHJcbiAgICB9XHJcbiAgICBtdXRhdGlvbnNbYHVwZGF0ZSR7c2luZ2xlLnBhc2NhbH1gXSA9IGZ1bmN0aW9uIChzdGF0ZSwgeyBpbmRleCwgaXRlbSB9KSB7XHJcbiAgICAgIFZ1ZS5zZXQoc3RhdGVbY29sbGVjdGlvbi5wbHVyYWxdLCBpbmRleCwgaXRlbSlcclxuICAgIH1cclxuICAgIG11dGF0aW9uc1tgZGVsZXRlJHtzaW5nbGUucGFzY2FsfWBdID0gZnVuY3Rpb24gKHN0YXRlLCBpbmRleCkge1xyXG4gICAgICBWdWUuZGVsZXRlKHN0YXRlW2NvbGxlY3Rpb24ucGx1cmFsXSwgaW5kZXgpXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHVwc2VydFByZWZpeCA9IGNvbGxlY3Rpb24udXBzZXJ0UHJlZml4IHx8IGRlZmF1bHRQcmVmaXhlcy51cHNlcnRQcmVmaXhcclxuICAgIGxldCBkZWxldGVQcmVmaXggPSBjb2xsZWN0aW9uLmRlbGV0ZVByZWZpeCB8fCBkZWZhdWx0UHJlZml4ZXMuZGVsZXRlUHJlZml4XHJcbiAgICBhY3Rpb25zW2Ake3Vwc2VydFByZWZpeH0ke3NpbmdsZS5wYXNjYWx9YF0gPSBmdW5jdGlvbiAoeyBjb21taXQsIGdldHRlcnMgfSwgaXRlbSkge1xyXG4gICAgICBsZXQgaW5kZXggPSBnZXR0ZXJzW2Ake3BsdXJhbC5jYW1lbH1JbmRleGBdLmdldChpdGVtW2NvbGxlY3Rpb24uaWRdKVxyXG4gICAgICBpZiAoaW5kZXggIT09IHZvaWQgMCkge1xyXG4gICAgICAgIGNvbW1pdChgdXBkYXRlJHtzaW5nbGUucGFzY2FsfWAsIHsgaW5kZXgsIGl0ZW0gfSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb21taXQoYGNyZWF0ZSR7c2luZ2xlLnBhc2NhbH1gLCBpdGVtKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBhY3Rpb25zW2Ake2RlbGV0ZVByZWZpeH0ke3NpbmdsZS5wYXNjYWx9YF0gPSBmdW5jdGlvbiAoeyBjb21taXQsIGdldHRlcnMgfSwgaWQpIHsgXHJcbiAgICAgIGxldCBpbmRleCA9IGdldHRlcnNbYCR7cGx1cmFsLmNhbWVsfUluZGV4YF0uZ2V0KGlkKVxyXG4gICAgICBpZiAoaW5kZXggIT09IHZvaWQgMCkge1xyXG4gICAgICAgIGNvbW1pdChgZGVsZXRlJHtzaW5nbGUucGFzY2FsfWAsIGluZGV4KVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbGxlY3Rpb24udHlwZSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIGxldCBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMobmV3IGNvbGxlY3Rpb24udHlwZSgpKVxyXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBjb25zdCBuYW1lcyA9IGdldENhc2VzKHByb3BlcnR5KVxyXG4gICAgICAgIGxldCBjb25qdW5jdGlvbiA9IHNpbmdsZS5wYXNjYWwubWF0Y2goL15bYWVpb3VdLiovaSkgPyAnQW4nIDogJ0EnXHJcbiAgICAgICAgYWN0aW9uc1tgc2V0JHtuYW1lcy5wYXNjYWx9T2Yke2Nvbmp1bmN0aW9ufSR7c2luZ2xlLnBhc2NhbH1gXSA9IGZ1bmN0aW9uICh7IGRpc3BhdGNoIH0sIHsgaWQsIHZhbHVlIH0pIHtcclxuICAgICAgICAgIHJldHVybiBkaXNwYXRjaCgnc2V0UHJvcGVydHlPZkFDb2xsZWN0aW9uSXRlbScsIHsgaWQsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24ucGx1cmFsLCBwcm9wZXJ0eSwgdmFsdWUgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXR0ZXJzW2Ake3BsdXJhbC5jYW1lbH1JbmRleGBdID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgIGxldCBfY29sbGVjdGlvbiA9IHN0YXRlW2NvbGxlY3Rpb24ucGx1cmFsXSB8fCBbXVxyXG4gICAgICByZXR1cm4gX2NvbGxlY3Rpb24ucmVkdWNlKChtYXAsIGl0ZW0sIGluZGljZSkgPT4ge1xyXG4gICAgICAgIG1hcC5zZXQoaXRlbVtjb2xsZWN0aW9uLmlkXSwgaW5kaWNlKVxyXG4gICAgICAgIHJldHVybiBtYXBcclxuICAgICAgfSwgbmV3IE1hcCgpKVxyXG4gICAgfVxyXG4gICAgZ2V0dGVyc1tgJHtzaW5nbGUuY2FtZWx9QnlJZGBdID0gZnVuY3Rpb24gKHN0YXRlLCBnZXR0ZXJzKSB7XHJcbiAgICAgIHJldHVybiAoaWQpID0+IHtcclxuICAgICAgICBsZXQgaW5kZXggPSBnZXR0ZXJzW2Ake3BsdXJhbC5jYW1lbH1JbmRleGBdLmdldChpZClcclxuICAgICAgICByZXR1cm4gaW5kZXggIT09IHZvaWQgMCA/IHN0YXRlW2NvbGxlY3Rpb24ucGx1cmFsXVtpbmRleF0gOiBudWxsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIG11dGF0aW9ucyxcclxuICAgIGFjdGlvbnMsXHJcbiAgICBnZXR0ZXJzXHJcbiAgfVxyXG59XHJcblxyXG4gLyoqXHJcbiAqIFRoZSBjb21wbGV0ZSBUcmlmb3JjZSwgb3Igb25lIG9yIG1vcmUgY29tcG9uZW50cyBvZiB0aGUgVHJpZm9yY2UuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbXBsZXhUeXBlXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGZpZWxkXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0eXBlIC0gdGhlIHR5cGUgb2YgdGhlIG9iamVjdFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYG11dGF0aW9uc2AgKHNldHRlcnMpIHJlbGF0ZWQgdG8gY29tcGxleCBmaWVsZHMuXHJcbiAqIEBwYXJhbSB7Q29tcGxleFR5cGVbXX0gY29tcGxleFR5cGVzIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGRlc2NyaWJlcyB5b3VyIGNvbGxlY3Rpb25cclxuICogQHJldHVybnMge09iamVjdH0gYSBvYmplY3Qgd2l0aCB0aGUgbWFwcGVkIG11dGF0aW9uc1xyXG4gKi9cclxuY29uc3QgbWFwU3RvcmVDb21wbGV4VHlwZXMgPSBmdW5jdGlvbiAoY29tcGxleFR5cGVzKSB7XHJcbiAgbGV0IG11dGF0aW9ucyA9IHt9XHJcbiAgZm9yIChsZXQgY29tcGxleFR5cGUgb2YgY29tcGxleFR5cGVzKSB7XHJcbiAgICBsZXQgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKG5ldyBjb21wbGV4VHlwZS50eXBlKCkpXHJcbiAgICBsZXQgdHlwZU5hbWUgPSBnZXRDYXNlcyhjb21wbGV4VHlwZS5uYW1lKVxyXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDYXNlcyhwcm9wZXJ0eSlcclxuICAgICAgbXV0YXRpb25zW2BzZXQke25hbWUucGFzY2FsfU9mJHt0eXBlTmFtZS5wYXNjYWx9YF0gPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlKSB7XHJcbiAgICAgICAgVnVlLnNldChzdGF0ZVtjb21wbGV4VHlwZS5uYW1lXSwgcHJvcGVydHksIHZhbHVlKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBtdXRhdGlvbnNcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYG11dGF0aW9uc2AgKHNldHRlcnMpIHJlbGF0ZWQgdG8gY29tcGxleCBmaWVsZHMuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGUgLSB0aGUgbW9kdWxlIG5hbWVcclxuICogQHBhcmFtIHtDb2xsZWN0aW9uSXRlbX0gcGFyYW1zIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGRlc2NyaWJlcyB5b3VyIGNvbGxlY3Rpb25cclxuICogQHJldHVybnMge09iamVjdH0gYSBvYmplY3Qgd2l0aCB0aGUgbWFwcGVkIG11dGF0aW9uc1xyXG4gKi9cclxuY29uc3QgbWFwQ29sbGVjdGlvbkl0ZW1TdGF0ZSA9IGZ1bmN0aW9uIChtb2R1bGUsIHsgaWQsIHNpbmdsZSwgdHlwZSwgdXBzZXJ0UHJlZml4IH0pIHtcclxuICBsZXQgbW9kdWxlTmFtZSA9IG1vZHVsZVxyXG4gIGxldCBzZXRNb2R1bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIG1vZHVsZU5hbWUgPSBuYW1lXHJcbiAgfVxyXG4gIGxldCBuYW1lID0gZ2V0Q2FzZXMoc2luZ2xlKVxyXG4gIGxldCBjb21wdXRlZCA9IHt9XHJcblxyXG4gIGxldCBnZXRFbnRpdHlCeUlkID0gYCR7bmFtZS5jYW1lbH1CeUlkYFxyXG4gIGxldCBlbnRpdHlOYW1lID0gYF9fJHtzaW5nbGV9YFxyXG4gIGNvbXB1dGVkW2dldEVudGl0eUJ5SWRdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbYCR7bW9kdWxlTmFtZX0vJHtnZXRFbnRpdHlCeUlkfWBdXHJcbiAgfVxyXG4gIGNvbXB1dGVkW2VudGl0eU5hbWVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXNbZ2V0RW50aXR5QnlJZF0odGhpc1tpZF0pXHJcbiAgfVxyXG5cclxuICBsZXQgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKG5ldyB0eXBlKCkpXHJcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XHJcbiAgICBjb25zdCBwcm9wTmFtZSA9IGdldENhc2VzKHByb3BlcnR5KVxyXG4gICAgbGV0IGNvbmp1bmN0aW9uID0gbmFtZS5jYW1lbC5tYXRjaCgvXlthZWlvdV0uKi9pKSA/ICdBbicgOiAnQSdcclxuICAgIGxldCBhY3Rpb25OYW1lID0gYHNldCR7cHJvcE5hbWUucGFzY2FsfU9mJHtjb25qdW5jdGlvbn0ke25hbWUucGFzY2FsfWBcclxuICAgIGNvbXB1dGVkW3Byb3BlcnR5XSA9IHtcclxuICAgICAgZ2V0ICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpc1tlbnRpdHlOYW1lXVtwcm9wZXJ0eV1cclxuICAgICAgfSxcclxuICAgICAgc2V0ICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKGAke21vZHVsZU5hbWV9LyR7YWN0aW9uTmFtZX1gLCB7IGlkOiB0aGlzW2lkXSwgdmFsdWUgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBzZXJ0UHJlZml4ID0gdXBzZXJ0UHJlZml4IHx8IGRlZmF1bHRQcmVmaXhlcy51cHNlcnRQcmVmaXhcclxuICBjb21wdXRlZFtzaW5nbGVdID0ge1xyXG4gICAgZ2V0ICgpIHtcclxuICAgICAgbGV0IGVudGl0eSA9IHt9XHJcbiAgICAgIGxldCBzY29wZSA9IHRoaXNcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudGl0eSwgcHJvcGVydHksIHtcclxuICAgICAgICAgIGdldCAoKSB7IHJldHVybiBzY29wZVtwcm9wZXJ0eV0gfSxcclxuICAgICAgICAgIHNldCAodmFsdWUpIHsgc2NvcGVbcHJvcGVydHldID0gdmFsdWUgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGVudGl0eVxyXG4gICAgfSxcclxuICAgIHNldCAodmFsdWUpIHtcclxuICAgICAgbGV0IHVwc2VydEFjdGlvbiA9IGAke21vZHVsZU5hbWV9LyR7dXBzZXJ0UHJlZml4fSR7bmFtZS5wYXNjYWx9YFxyXG4gICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCh1cHNlcnRBY3Rpb24sIHZhbHVlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHNldE1vZHVsZU5hbWUsXHJcbiAgICBjb21wdXRlZFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBgbXV0YXRpb25zYCAoc2V0dGVycykgcmVsYXRlZCB0byBjb21wbGV4IGZpZWxkcy5cclxuICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZSAtIHRoZSBtb2R1bGUgbmFtZVxyXG4gKiBAcGFyYW0ge0NvbXBsZXhUeXBlfSBwYXJhbXMgLSBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgZGVzY3JpYmVzIHlvdXIgY29sbGVjdGlvblxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIG9iamVjdCB3aXRoIHRoZSBtYXBwZWQgbXV0YXRpb25zXHJcbiAqL1xyXG5jb25zdCBtYXBDb21wbGV4VHlwZVN0YXRlID0gZnVuY3Rpb24gKG1vZHVsZSwgeyBuYW1lLCB0eXBlIH0pIHtcclxuICBsZXQgbW9kdWxlTmFtZSA9IG1vZHVsZVxyXG4gIGxldCBzZXRNb2R1bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIG1vZHVsZU5hbWUgPSBuYW1lXHJcbiAgfVxyXG4gIGxldCBzaW5nbGUgPSBnZXRDYXNlcyhuYW1lKVxyXG4gIGxldCBjb21wdXRlZCA9IHt9XHJcblxyXG4gIGxldCBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMobmV3IHR5cGUoKSlcclxuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcclxuICAgIGNvbnN0IHByb3BOYW1lID0gZ2V0Q2FzZXMocHJvcGVydHkpXHJcbiAgICBsZXQgYWN0aW9uTmFtZSA9IGBzZXQke3Byb3BOYW1lLnBhc2NhbH1PZiR7c2luZ2xlLnBhc2NhbH1gXHJcbiAgICBjb21wdXRlZFtwcm9wZXJ0eV0gPSB7XHJcbiAgICAgIGdldCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdW25hbWVdW3Byb3BlcnR5XVxyXG4gICAgICB9LFxyXG4gICAgICBzZXQgKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KGAke21vZHVsZU5hbWV9LyR7YWN0aW9uTmFtZX1gLCB2YWx1ZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29tcHV0ZWRbbmFtZV0gPSB7XHJcbiAgICBnZXQgKCkge1xyXG4gICAgICBsZXQgZW50aXR5ID0ge31cclxuICAgICAgbGV0IHNjb3BlID0gdGhpc1xyXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZW50aXR5LCBwcm9wZXJ0eSwge1xyXG4gICAgICAgICAgZ2V0ICgpIHsgcmV0dXJuIHNjb3BlW3Byb3BlcnR5XSB9LFxyXG4gICAgICAgICAgc2V0ICh2YWx1ZSkgeyBzY29wZVtwcm9wZXJ0eV0gPSB2YWx1ZSB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZW50aXR5XHJcbiAgICB9LFxyXG4gICAgc2V0ICh2YWx1ZSkge1xyXG4gICAgICB0aGlzLiRzdG9yZS5jb21taXQoYCR7bW9kdWxlTmFtZX0vJHtuYW1lfWAsIHZhbHVlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHNldE1vZHVsZU5hbWUsXHJcbiAgICBjb21wdXRlZFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHtcclxuICBnZXRDb2xsZWN0aW9uUHJlZml4ZXMsXHJcbiAgc2V0Q29sbGVjdGlvblByZWZpeGVzLFxyXG4gIG1hcFN0YXRlLFxyXG4gIG1hcEdldHRlcnMsXHJcbiAgbWFwU3RvcmVNdXRhdGlvbnMsXHJcbiAgbWFwU3RvcmVDb2xsZWN0aW9ucyxcclxuICBtYXBTdG9yZUNvbXBsZXhUeXBlcyxcclxuICBtYXBDb2xsZWN0aW9uSXRlbVN0YXRlLFxyXG4gIG1hcENvbXBsZXhUeXBlU3RhdGVcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGdldENvbGxlY3Rpb25QcmVmaXhlcyxcclxuICBzZXRDb2xsZWN0aW9uUHJlZml4ZXMsXHJcbiAgbWFwU3RhdGUsXHJcbiAgbWFwR2V0dGVycyxcclxuICBtYXBTdG9yZU11dGF0aW9ucyxcclxuICBtYXBTdG9yZUNvbGxlY3Rpb25zLFxyXG4gIG1hcFN0b3JlQ29tcGxleFR5cGVzLFxyXG4gIG1hcENvbGxlY3Rpb25JdGVtU3RhdGUsXHJcbiAgbWFwQ29tcGxleFR5cGVTdGF0ZVxyXG59XHJcbiIsImltcG9ydCB7IHVpZCB9IGZyb20gJ3F1YXNhcidcclxuXHJcbi8qKlxyXG4gKiBjcmVhdGVzIGEgY29tYiAoY29tYmluZWQgdGltZS11dWlkKVxyXG4gKiBAcGFyYW0geyp9IGRhdGUgLSBkYXRlIHVzZWQgdG8gY3JlYXRlIHRoZSBDT01CXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJldHVybnMgYSBjb21iaW5lZCB0aW1lLXV1aWQgKGNvbWIpXHJcbiAqL1xyXG5jb25zdCBjb21iID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICBpZiAoIWRhdGUpIHtcclxuICAgIGRhdGUgPSBuZXcgRGF0ZSgpXHJcbiAgfVxyXG4gIGxldCB1dWlkID0gdWlkKClcclxuICBsZXQgY29tYiA9ICgnMDAwMDAwMDAwMDAnICsgZGF0ZS5nZXRUaW1lKCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTEyKVxyXG4gIGNvbWIgPSBjb21iLnNsaWNlKDAsIDgpICsgJy0nICsgY29tYi5zbGljZSg4LCAxMilcclxuICByZXR1cm4gdXVpZC5yZXBsYWNlKHV1aWQuc2xpY2UoMCwgMTMpLCBjb21iKVxyXG59XHJcblxyXG4vKipcclxuICogZXh0cmFjdCB0aGUgZGF0ZSBwYXJ0IG9mIHRoZSBjb21iXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21iIGEgY29tYmluZWQgdGltZS11dWlkIChjb21iKVxyXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIGRhdGUgcGFydCBvZiB0aGUgY29tYlxyXG4gKi9cclxuY29uc3QgZXh0cmFjdCA9IGZ1bmN0aW9uIChjb21iKSB7XHJcbiAgbGV0IHRleHQgPSBjb21iLnJlcGxhY2UoLy0vZywgJycpLnN1YnN0cigwLCAxMilcclxuICBsZXQgdGltZSA9IHBhcnNlSW50KHRleHQsIDE2KVxyXG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lKVxyXG59XHJcblxyXG5leHBvcnQge1xyXG4gIGNvbWIsXHJcbiAgZXh0cmFjdFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgY29tYixcclxuICBleHRyYWN0XHJcbn1cclxuIiwiXHJcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5pbXBvcnQgeyBtYXBTdGF0ZSwgbWFwU3RvcmVNdXRhdGlvbnMsIG1hcFN0b3JlQ29sbGVjdGlvbnMsIG1hcFN0b3JlQ29tcGxleFR5cGVzLCBnZXRDb2xsZWN0aW9uUHJlZml4ZXMgfSBmcm9tICcuL3N0b3JlJ1xyXG5pbXBvcnQgdXVpZCBmcm9tICcuL3V1aWQnXHJcbmltcG9ydCB7IGdldENhc2VzLCBnZXRQZWVyIH0gZnJvbSAnLi9fY29tbW9uJ1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjb21wbGV0ZSBUcmlmb3JjZSwgb3Igb25lIG9yIG1vcmUgY29tcG9uZW50cyBvZiB0aGUgVHJpZm9yY2UuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbXBvbmVudEZhY3RvcnlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVuZGVyIC0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZXZlcnl0aW1lIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWQ6IHJlbmRlciAoeyBzZWxmLCBvcHRpb25zIH0pIHsgfVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR1cCAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZWFkeSB0byBiZSByZXR1cm5lZDogc2V0dXAoeyBjb21wb25lbnQgfSkgeyB9XHJcbiAqL1xyXG5cclxuIC8qKlxyXG4gKiBUaGUgY29tcGxldGUgVHJpZm9yY2UsIG9yIG9uZSBvciBtb3JlIGNvbXBvbmVudHMgb2YgdGhlIFRyaWZvcmNlLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xsZWN0aW9uSXRlbVxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gc2luZ2xlIC0gdGhlIHNpbmdsZSBmb3JtIG9mIHRoZSBjb2xsZWN0aW9uIChpdGVtLCBwZXJzb24sIGpvYilcclxuICogQHByb3BlcnR5IHtTdHJpbmd9IHBsdXJhbCAtIHRoZSBwbHVyYWwgZm9ybSBvZiB0aGUgY29sbGVjdGlvbiAobGlzdCwgcGVvcGxlLCBqb2JzKSwgd291bGQgYmUgdGhlIHNhbWUgYXMgaW4gdGhlIHN0YXRlXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBpZCAtIHRoZSBuYW1lIG9mIHRoZSBpZCBmaWVsZCBvZiB0aGUgb2JqZWN0IGluIHRoZSBjb2xsZWN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0eXBlIC0gdGhlIHR5cGUgb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5XHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdXBzZXJ0UHJlZml4PSdzYXZlT3JVcGRhdGUnXSAtIHByZWZpeCBvZiB0aGUgc2F2ZSBvciB1cGRhdGUgYWN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZGVsZXRlUHJlZml4PSdkZWxldGUnXSAtIHByZWZpeCBvZiB0aGUgZGVsZXRlIGFjdGlvblxyXG4gKi9cclxuXHJcbiAvKipcclxuICogVGhlIGNvbXBsZXRlIFRyaWZvcmNlLCBvciBvbmUgb3IgbW9yZSBjb21wb25lbnRzIG9mIHRoZSBUcmlmb3JjZS5cclxuICogQHR5cGVkZWYge09iamVjdH0gQ29tcGxleFR5cGVcclxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZmllbGRcclxuICogQHByb3BlcnR5IHtPYmplY3R9IHR5cGUgLSB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIHdyYXBwZXIgYSBjb21wb25lbnQgYW5kIGFsbG93IHRoZW0gdG8gYmUgbW9kaWZpZWQgYXQgdGhlIHJlbmRlciB0aW1lLCBvciBldmVuIHNldHVwIHlvdXIgcHJvcGVydGllcywgc2xvdHMsIGV0Yy5cclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbS5uYW1lIC0gY29tcG9uZW50J3MgbmFtZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW0uY29tcG9uZW50IC0gY29tcG9uZW50IHRvIGJlIHdyYXBwZWRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW0ucmVuZGVyIC0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZXZlcnl0aW1lIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWQ6IHJlbmRlciAoeyBzZWxmLCBvcHRpb25zIH0pIHsgfVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJhbS5zZXR1cCAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZWFkeSB0byBiZSByZXR1cm5lZDogc2V0dXAoeyBjb21wb25lbnQgfSkgeyB9XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJhbS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uIChoLCBjb21wb25lbnQsIG9wdGlvbnMpIHtcclxuICAgICByZXR1cm4gaChjb21wb25lbnQsIG9wdGlvbnMpXHJcbiAgIH1dXHJcbiAqIEBwYXJhbSB7Q29tcG9uZW50RmFjdG9yeVtdfSBwYXJhbS5mYWN0b3JpZXMgLSBhcnJheSBvZiBvYmplY3RzIHdpdGggYSByZW5kZXIgYW5kL29yIHNldHVwIGZpZWxkXHJcbiAqL1xyXG5jb25zdCBjb21wb25lbnQgPSBmdW5jdGlvbiAoeyBuYW1lLCBjb21wb25lbnQsIHJlbmRlciwgc2V0dXAsIGNyZWF0ZUVsZW1lbnQsIGZhY3RvcmllcyB9KSB7XHJcbiAgY29uc3QgcHJvcHMgPSBjb21wb25lbnQub3B0aW9ucy5wcm9wc1xyXG4gIGNvbnN0IGNvbXB1dGVkID0ge31cclxuICBpZiAocHJvcHMudmFsdWUpIHtcclxuICAgIGNvbXB1dGVkLl9fdmFsdWUgPSB7XHJcbiAgICAgIGdldCAoKSB7IHJldHVybiB0aGlzLnZhbHVlIH0sXHJcbiAgICAgIHNldCAodmFsdWUpIHsgcmV0dXJuIHRoaXMuJGVtaXQoJ2lucHV0JywgdmFsdWUpIH1cclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgbWV0aG9kcyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudC5vcHRpb25zLm1ldGhvZHMgfHwge30pLnJlZHVjZSgobWV0aG9kcywga2V5KSA9PiB7XHJcbiAgICBtZXRob2RzW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICBsZXQgcm9vdCA9IHRoaXMuJHJlZnMucm9vdFxyXG4gICAgICByZXR1cm4gcm9vdFtrZXldLmFwcGx5KHJvb3QsIGFyZ3MpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWV0aG9kc1xyXG4gIH0sIHt9KVxyXG5cclxuICBmYWN0b3JpZXMgPSBmYWN0b3JpZXMgfHwgW11cclxuICBjb25zdCByZW5kZXJzID0gZmFjdG9yaWVzLmZpbHRlcihpdGVtID0+IGl0ZW0ucmVuZGVyKS5tYXAoaXRlbSA9PiBpdGVtLnJlbmRlcilcclxuICBpZiAocmVuZGVyKSB7XHJcbiAgICByZW5kZXJzLnB1c2gocmVuZGVyKVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2V0dXBzID0gZmFjdG9yaWVzLmZpbHRlcihpdGVtID0+IGl0ZW0uc2V0dXApLm1hcChpdGVtID0+IGl0ZW0uc2V0dXApXHJcbiAgaWYgKHNldHVwKSB7XHJcbiAgICBzZXR1cHMucHVzaChzZXR1cClcclxuICB9XHJcblxyXG4gIGlmICghY3JlYXRlRWxlbWVudCkge1xyXG4gICAgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChoLCBjb21wb25lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIGgoY29tcG9uZW50LCBvcHRpb25zKVxyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgd3JhcHBlciA9IHtcclxuICAgIG5hbWU6IG5hbWUsXHJcbiAgICBwcm9wczogcHJvcHMsXHJcbiAgICBtZXRob2RzOiBtZXRob2RzLFxyXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkLFxyXG4gICAgcmVuZGVyIChoKSB7XHJcbiAgICAgIGxldCBzZWxmID0gdGhpc1xyXG4gICAgICBsZXQga2V5ID0gdGhpcy4kdm5vZGUua2V5XHJcbiAgICAgIGxldCBvcHRpb25zID0ge1xyXG4gICAgICAgIGtleToga2V5LFxyXG4gICAgICAgIHJlZjogJ3Jvb3QnLFxyXG4gICAgICAgIHNjb3BlZFNsb3RzOiB0aGlzLiRzY29wZWRTbG90cyxcclxuICAgICAgICBhdHRyczogdGhpcy4kYXR0cnNcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcHMudmFsdWUpIHtcclxuICAgICAgICBsZXQgeyB2YWx1ZXMsIC4uLnByb3BzIH0gPSB0aGlzLiRwcm9wc1xyXG4gICAgICAgIGxldCB7IGlucHV0LCAuLi5saXN0ZW5lcnMgfSA9IHRoaXMuJGxpc3RlbmVyc1xyXG4gICAgICAgIHByb3BzLnZhbHVlID0gc2VsZi5fX3ZhbHVlXHJcbiAgICAgICAgbGlzdGVuZXJzLmlucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICBzZWxmLl9fdmFsdWUgPSB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRpb25zLnByb3BzID0gcHJvcHNcclxuICAgICAgICBvcHRpb25zLm9uID0gbGlzdGVuZXJzXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IHsgLi4ucHJvcHMgfSA9IHRoaXMuJHByb3BzXHJcbiAgICAgICAgbGV0IHsgLi4ubGlzdGVuZXJzIH0gPSB0aGlzLiRsaXN0ZW5lcnNcclxuICAgICAgICBvcHRpb25zLnByb3BzID0gcHJvcHNcclxuICAgICAgICBvcHRpb25zLm9uID0gbGlzdGVuZXJzXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IHJlbmRlciBvZiByZW5kZXJzKSB7XHJcbiAgICAgICAgcmVuZGVyKHsgc2VsZiwgb3B0aW9ucyB9KVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGgsIGNvbXBvbmVudCwgb3B0aW9ucylcclxuICAgIH1cclxuICB9XHJcbiAgZm9yIChsZXQgc2V0dXAgb2Ygc2V0dXBzKSB7XHJcbiAgICBzZXR1cCh7IGNvbXBvbmVudDogd3JhcHBlciB9KVxyXG4gIH1cclxuICByZXR1cm4gd3JhcHBlclxyXG59XHJcblxyXG5jb25zdCBfX2NvbXBvbmVudCA9IGNvbXBvbmVudFxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBicmFuZFxyXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl9IGJyYW5kLnN0eWxlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gYnJhbmQuY2xhc3NcclxuICogQHBhcmFtIHtPYmplY3R9IGJyYW5kLnByb3BzXHJcbiAqL1xyXG5jb25zdCByZUJyYW5kID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNvbXBvbmVudCwgYnJhbmQpIHtcclxuICBsZXQgbmFtZSA9ICcnLCBjbmFtZSA9ICcnLCByZWdpc3RlciA9IG51bGxcclxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICBuYW1lID0gb3B0aW9ucy5uYW1lXHJcbiAgICBjbmFtZSA9IG9wdGlvbnMuY25hbWVcclxuICAgIGNvbXBvbmVudCA9IG9wdGlvbnMuY29tcG9uZW50XHJcbiAgICBicmFuZCA9IG9wdGlvbnMuYnJhbmRcclxuICAgIHJlZ2lzdGVyID0gb3B0aW9ucy5yZWdpc3RlclxyXG4gIH0gZWxzZSB7XHJcbiAgICBuYW1lID0gb3B0aW9uc1xyXG4gIH1cclxuICBpZiAoIWNuYW1lKSB7XHJcbiAgICBjbmFtZSA9IGdldENhc2VzKG5hbWUpLnBhc2NhbFxyXG4gIH1cclxuICBpZiAoIXJlZ2lzdGVyKSB7XHJcbiAgICByZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLCBjb21wb25lbnQpIHtcclxuICAgICAgVnVlLmNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGJyYW5kLnByb3BzIHx8IHt9KVxyXG4gIHJlZ2lzdGVyKG5hbWUsIF9fY29tcG9uZW50KHtcclxuICAgIG5hbWU6IGNuYW1lIHx8IGNvbXBvbmVudC5uYW1lLFxyXG4gICAgY29tcG9uZW50LFxyXG4gICAgcmVuZGVyICh7IHNlbGYsIG9wdGlvbnMgfSkge1xyXG4gICAgICBpZiAoYnJhbmQuc3R5bGUpIHtcclxuICAgICAgICBvcHRpb25zLnN0eWxlID0gYnJhbmQuc3R5bGVcclxuICAgICAgfVxyXG4gICAgICBpZiAoYnJhbmQuY2xhc3MpIHtcclxuICAgICAgICBvcHRpb25zLmNsYXNzID0gYnJhbmQuY2xhc3NcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xyXG4gICAgICAgIG9wdGlvbnMucHJvcHNbcHJvcF0gPSBvcHRpb25zLnByb3BzW3Byb3BdID09PSB1bmRlZmluZWQgPyBicmFuZC5wcm9wc1twcm9wXSA6IG9wdGlvbnMucHJvcHNbcHJvcF1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSxcclxuICAgIHNldHVwICh7IGNvbXBvbmVudCB9KSB7XHJcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XHJcbiAgICAgICAgY29tcG9uZW50LnByb3BzW3Byb3BdLmRlZmF1bHQgPSAoKSA9PiB1bmRlZmluZWRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pKVxyXG59XHJcblxyXG5jb25zdCBtZXJnZSA9IGZ1bmN0aW9uICh7IG5hbWUsIG1vZGVsLCBjb2xsZWN0aW9ucywgY29tcGxleFR5cGVzLCB1c2VyIH0pIHtcclxuICBsZXQgY29uZGl0aW9ucyA9IFtcclxuICAgIG1vZGVsICYmIG1vZGVsW25hbWVdLFxyXG4gICAgY29sbGVjdGlvbnMgJiYgY29sbGVjdGlvbnNbbmFtZV0sXHJcbiAgICAhIXVzZXJcclxuICBdLmZpbHRlcihjb25kaXRpb24gPT4gY29uZGl0aW9uKVxyXG5cclxuICBpZiAoY29uZGl0aW9ucy5sZW5ndGggPiAxKSB7XHJcbiAgICBsZXQgbWVyZ2VkID0ge31cclxuICAgIGxldCBpc0Z1bmMgPSBmYWxzZVxyXG4gICAgaWYgKHVzZXIpIHtcclxuICAgICAgaXNGdW5jID0gaXNGdW5jIHx8IHVzZXIuY2FsbFxyXG4gICAgICBtZXJnZWQgPSB1c2VyLmNhbGwgPyB7IC4uLm1lcmdlZCwgLi4udXNlcigpIH0gOiB7IC4uLm1lcmdlZCwgLi4udXNlciB9XHJcbiAgICB9XHJcbiAgICBpZiAobW9kZWwgJiYgbW9kZWxbbmFtZV0pIHtcclxuICAgICAgaXNGdW5jID0gaXNGdW5jIHx8IG1vZGVsW25hbWVdLmNhbGxcclxuICAgICAgbWVyZ2VkID0gbW9kZWxbbmFtZV0uY2FsbCA/IHsgLi4ubWVyZ2VkLCAuLi5tb2RlbFtuYW1lXSgpIH0gOiB7IC4uLm1lcmdlZCwgLi4ubW9kZWxbbmFtZV0gfVxyXG4gICAgfVxyXG4gICAgaWYgKGNvbGxlY3Rpb25zICYmIGNvbGxlY3Rpb25zW25hbWVdKSB7XHJcbiAgICAgIGlzRnVuYyA9IGlzRnVuYyB8fCBjb2xsZWN0aW9uc1tuYW1lXS5jYWxsXHJcbiAgICAgIG1lcmdlZCA9IGNvbGxlY3Rpb25zW25hbWVdLmNhbGwgPyB7IC4uLm1lcmdlZCwgLi4uY29sbGVjdGlvbnNbbmFtZV0oKSB9IDogeyAuLi5tZXJnZWQsIC4uLmNvbGxlY3Rpb25zW25hbWVdIH1cclxuICAgIH1cclxuICAgIGlmIChjb21wbGV4VHlwZXMgJiYgY29tcGxleFR5cGVzW25hbWVdKSB7XHJcbiAgICAgIGlzRnVuYyA9IGlzRnVuYyB8fCBjb21wbGV4VHlwZXNbbmFtZV0uY2FsbFxyXG4gICAgICBtZXJnZWQgPSBjb21wbGV4VHlwZXNbbmFtZV0uY2FsbCA/IHsgLi4ubWVyZ2VkLCAuLi5jb21wbGV4VHlwZXNbbmFtZV0oKSB9IDogeyAuLi5tZXJnZWQsIC4uLmNvbXBsZXhUeXBlc1tuYW1lXSB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNGdW5jKSB7XHJcbiAgICAgIGxldCBfX21lcmdlZCA9IG1lcmdlZFxyXG4gICAgICBtZXJnZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoX19tZXJnZWQpKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVyZ2VkXHJcbiAgfSBlbHNlIGlmIChtb2RlbCAmJiBtb2RlbFtuYW1lXSkge1xyXG4gICAgcmV0dXJuIG1vZGVsW25hbWVdXHJcbiAgfSBlbHNlIGlmIChjb2xsZWN0aW9ucyAmJiBjb2xsZWN0aW9uc1tuYW1lXSkge1xyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb25zW25hbWVdXHJcbiAgfSBlbHNlIGlmIChjb21wbGV4VHlwZXMgJiYgY29tcGxleFR5cGVzW25hbWVdKSB7XHJcbiAgICByZXR1cm4gY29tcGxleFR5cGVzW25hbWVdXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB1c2VyXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBwcmVwZXJWYWxpZGF0aW9uID0gZnVuY3Rpb24gKHsgc3RvcmUsIGZpZWxkcyB9KSB7XHJcbiAgc3RvcmUubXV0YXRpb25zID0gc3RvcmUubXV0YXRpb25zIHx8IHt9XHJcbiAgY29uc3QgZmllbGRLZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKVxyXG4gIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRLZXlzKSB7XHJcbiAgICBzdG9yZS5tdXRhdGlvbnNbZmllbGRdID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSkgeyBzdGF0ZVtmaWVsZF0gPSB2YWx1ZSB9XHJcbiAgfVxyXG4gIFxyXG4gIHN0b3JlLnN0YXRlID0gc3RvcmUuc3RhdGUgfHwge31cclxuICBsZXQgaXNGdW5jID0gISFzdG9yZS5zdGF0ZS5jYWxsXHJcbiAgaWYgKGlzRnVuYykge1xyXG4gICAgc3RvcmUuc3RhdGUgPSBzdG9yZS5zdGF0ZSgpXHJcbiAgfVxyXG4gIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRLZXlzKSB7XHJcbiAgICBzdG9yZS5zdGF0ZVtmaWVsZF0gPSBmaWVsZHNbZmllbGRdXHJcbiAgfVxyXG4gIGlmIChpc0Z1bmMpIHtcclxuICAgIGxldCBvYmogPSBzdG9yZS5zdGF0ZVxyXG4gICAgc3RvcmUuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB7IC4uLm9iaiB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0aW9uRmllbGQgPSAnQEAnXHJcbmNvbnN0IGZldGNoZWRGaWVsZCA9ICdAdG11X2ZldGNoZWQnXHJcbi8qKlxyXG4gKiBmYWN0b3J5LnN0b3JlIGNvbWJpbmVzIHN0b3JlLm1hcFN0b3JlTXV0YXRpb25zIGFuZCBzdG9yZS5tYXBTdG9yZUNvbGxlY3Rpb25zLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gLSB0aGUgcGFnZSBwcm9wZXJ0aWVzIChgY3JlYXRlZGAsIGBjb21wdXRlZGAsIGBldGNgKVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW0ub3B0aW9ucyAtIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgcGFnZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW0ub3B0aW9ucy5tb2RlbCAtIGNsYXNzIHVzZWQgdG8gbW9kZWwgdGhlIG11dGF0aW9ucyBvYmplY3RcclxuICogQHBhcmFtIHtDb2xsZWN0aW9uSXRlbVtdfSBwYXJhbS5vcHRpb25zLmNvbGxlY3Rpb25zIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGRlc2NyaWJlcyB5b3VyIGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtDb21wbGV4VHlwZVtdfSBwYXJhbS5vcHRpb25zLmNvbGxlY3Rpb25zIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGRlc2NyaWJlcyB5b3VyIGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtLnN0YXRlIC0gbW9kdWxlJ3Mgc3RhdGUsIHRoYXQgd2lsbCBiZSBtZXJnZWQgaW50cm8gdGhlIGZpbmFsIG1vZHVsZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW0ubXV0YXRpb25zIC0gbW9kdWxlJ3MgbXV0YXRpb25zLCB0aGF0IHdpbGwgYmUgbWVyZ2VkIGludHJvIHRoZSBmaW5hbCBtb2R1bGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtLmFjdGlvbnMgLSBtb2R1bGUncyBhY3Rpb25zLCB0aGF0IHdpbGwgYmUgbWVyZ2VkIGludHJvIHRoZSBmaW5hbCBtb2R1bGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtLmdldHRlcnMgLSBtb2R1bGUncyBnZXR0ZXJzLCB0aGF0IHdpbGwgYmUgbWVyZ2VkIGludHJvIHRoZSBmaW5hbCBtb2R1bGVcclxuICovXHJcbmNvbnN0IHN0b3JlID0gZnVuY3Rpb24gKHsgb3B0aW9ucywgaW5pdGlhbGl6ZSwgLi4uc3RvcmUgfSkge1xyXG4gIGxldCBtb2RlbCwgY29sbGVjdGlvbnMsIGNvbXBsZXhUeXBlc1xyXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubW9kZWwpIHtcclxuICAgIG1vZGVsID0ge1xyXG4gICAgICBzdGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgb3B0aW9ucy5tb2RlbCgpXHJcbiAgICAgIH0sXHJcbiAgICAgIG11dGF0aW9uczogbWFwU3RvcmVNdXRhdGlvbnMob3B0aW9ucy5tb2RlbClcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb2xsZWN0aW9ucyAmJiBvcHRpb25zLmNvbGxlY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgIGNvbGxlY3Rpb25zID0gbWFwU3RvcmVDb2xsZWN0aW9ucyhvcHRpb25zLmNvbGxlY3Rpb25zKVxyXG4gIH1cclxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXhUeXBlcyAmJiBvcHRpb25zLmNvbXBsZXhUeXBlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBjb21wbGV4VHlwZXMgPSBtYXBTdG9yZUNvbXBsZXhUeXBlcyhvcHRpb25zLmNvbXBsZXhUeXBlcylcclxuICB9XHJcblxyXG4gIHByZXBlclZhbGlkYXRpb24oeyBzdG9yZSwgZmllbGRzOiB7IFt2YWxpZGF0aW9uRmllbGRdOiAwLCBbZmV0Y2hlZEZpZWxkXTogZmFsc2UgfSB9KVxyXG4gIHN0b3JlLm5hbWVzcGFjZWQgPSB0cnVlXHJcbiAgc3RvcmUuc3RhdGUgPSBtZXJnZSh7IG5hbWU6ICdzdGF0ZScsIG1vZGVsLCBjb2xsZWN0aW9ucywgY29tcGxleFR5cGVzLCAgdXNlcjogc3RvcmUuc3RhdGUgfSlcclxuICBzdG9yZS5tdXRhdGlvbnMgPSBtZXJnZSh7IG5hbWU6ICdtdXRhdGlvbnMnLCBtb2RlbCwgY29sbGVjdGlvbnMsIGNvbXBsZXhUeXBlcywgdXNlcjogc3RvcmUubXV0YXRpb25zIH0pIHx8IHt9XHJcbiAgc3RvcmUuYWN0aW9ucyA9IG1lcmdlKHsgbmFtZTogJ2FjdGlvbnMnLCBtb2RlbCwgY29sbGVjdGlvbnMsIGNvbXBsZXhUeXBlcywgdXNlcjogc3RvcmUuYWN0aW9ucyB9KSB8fCB7fVxyXG4gIHN0b3JlLmdldHRlcnMgPSBtZXJnZSh7IG5hbWU6ICdnZXR0ZXJzJywgbW9kZWwsIGNvbGxlY3Rpb25zLCBjb21wbGV4VHlwZXMsIHVzZXI6IHN0b3JlLmdldHRlcnMgfSlcclxuICBpZiAoIXN0b3JlLmFjdGlvbnMuaW5pdGlhbGl6ZSkge1xyXG4gICAgc3RvcmUuYWN0aW9ucy5pbml0aWFsaXplID0gaW5pdGlhbGl6ZSB8fCBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWVzKSB7fVxyXG4gIH1cclxuICByZXR1cm4gc3RvcmVcclxufVxyXG5cclxuLyoqXHJcbiAqIGZhY3RvcnkucGFnZSB3aWxsIGV4cGVjdCB0aGUgc2FtZSBvcHRpb25zIGFzIGZhY3Rvcnkuc3RvcmUgYW5kIHdpbGwgbWFwIHRoZSBzdGF0ZSwgbXV0YXRpb25zLCBhY3Rpb25zIGFuZCBnZXR0ZXJzIGdlbmVyYXRlZCBieSBmYWN0b3J5LnN0b3JlIHRvIHRoZSBwYWdlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gLSB0aGUgcGFnZSBwcm9wZXJ0aWVzIChgY3JlYXRlZGAsIGBjb21wdXRlZGAsIGBldGNgKVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW0ub3B0aW9ucyAtIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgcGFnZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW0ub3B0aW9ucy5tb2RlbCAtIGNsYXNzIHVzZWQgdG8gbW9kZWwgdGhlIG11dGF0aW9ucyBvYmplY3RcclxuICogQHBhcmFtIHtDb2xsZWN0aW9uSXRlbVtdfSBwYXJhbS5vcHRpb25zLmNvbGxlY3Rpb25zIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGRlc2NyaWJlcyB5b3VyIGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtLnN0b3JlTW9kdWxlIC0gaWYgbm90IG51bGwsIGl0J2xsIGJlIHJlZ2lzdGVyZWQgaW4gdGhlIHByZUZldGNoIG9yIGluIHRoZSBjcmVhdGVkIGhvb2ssIGFuZCByZW1vdmVkIGluIHRoZSBkZXN0cm95ZWQgaG9vay5cclxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtLm1vZHVsZU5hbWUgLSB0aGUgcHJlZml4IG9mIHRoZSBwcml2YXRlIGZpZWxkcyB1c2VkIGJ5IHRoZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcbiAqL1xyXG5jb25zdCBwYWdlID0gZnVuY3Rpb24gKHsgb3B0aW9ucywgc3RvcmVNb2R1bGUsIG1vZHVsZU5hbWUsIC4uLnBhZ2UgfSkge1xyXG4gIGxldCB7IHByZUZldGNoLCBjcmVhdGVkLCBtb3VudGVkLCBkZXN0cm95ZWQgfSA9IHBhZ2VcclxuXHJcbiAgY29uc3QgY2hlY2tNb2R1bGUgPSBmdW5jdGlvbiAoeyBzdG9yZSwgc3VjY2VzcywgZmFpbHVyZSB9KSB7XHJcbiAgICBpZiAoc3RvcmVNb2R1bGUubXV0YXRpb25zW3ZhbGlkYXRpb25GaWVsZF0pIHtcclxuICAgICAgbGV0IGNvbWIgPSB1dWlkLmNvbWIoKVxyXG4gICAgICBsZXQgbXV0YXRpb25OYW1lID0gYCR7bW9kdWxlTmFtZX0vJHt2YWxpZGF0aW9uRmllbGR9YFxyXG4gICAgICBpZiAoc3RvcmUuc3RhdGVbbW9kdWxlTmFtZV0gJiYgc3RvcmUuX211dGF0aW9uc1ttdXRhdGlvbk5hbWVdKSB7XHJcbiAgICAgICAgc3RvcmUuY29tbWl0KG11dGF0aW9uTmFtZSwgY29tYilcclxuICAgICAgICBsZXQgdmFsdWUgPSAoc3RvcmUuc3RhdGVbbW9kdWxlTmFtZV0gfHwge30pW3ZhbGlkYXRpb25GaWVsZF1cclxuICAgICAgICBpZiAodmFsdWUgPT09IGNvbWIpIHtcclxuICAgICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGZhaWx1cmUpIGZhaWx1cmUoKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChmYWlsdXJlKSB7XHJcbiAgICAgICAgZmFpbHVyZSgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChzdG9yZU1vZHVsZSkge1xyXG4gICAgcGFnZS5wcmVGZXRjaCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgIGxldCBzZWxmID0gdGhpc1xyXG4gICAgICBsZXQgeyBzdG9yZSwgY3VycmVudFJvdXRlLCBwcmV2aW91c1JvdXRlLCByZWRpcmVjdCB9ID0gY29udGV4dFxyXG4gICAgICBjaGVja01vZHVsZSh7XHJcbiAgICAgICAgc3RvcmUsXHJcbiAgICAgICAgc3VjY2VzcyAoKSB7XHJcbiAgICAgICAgICBzdG9yZS51bnJlZ2lzdGVyTW9kdWxlKG1vZHVsZU5hbWUpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICBzdG9yZS5yZWdpc3Rlck1vZHVsZShtb2R1bGVOYW1lLCBzdG9yZU1vZHVsZSlcclxuICAgICAgbGV0IGZldGNoZWQgPSBzdG9yZS5zdGF0ZVttb2R1bGVOYW1lXSAmJiBzdG9yZS5zdGF0ZVttb2R1bGVOYW1lXVtmZXRjaGVkRmllbGRdXHJcbiAgICAgIGlmICghZmV0Y2hlZCkge1xyXG4gICAgICAgIGZldGNoZWQgPSBzdG9yZS5kaXNwYXRjaChgJHttb2R1bGVOYW1lfS9pbml0aWFsaXplYCwge1xyXG4gICAgICAgICAgcm91dGU6IGN1cnJlbnRSb3V0ZSxcclxuICAgICAgICAgIGZyb206IHByZXZpb3VzUm91dGUsXHJcbiAgICAgICAgICBuZXh0OiByZWRpcmVjdFxyXG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc3RvcmUuY29tbWl0KGAke21vZHVsZU5hbWV9LyR7ZmV0Y2hlZEZpZWxkfWAsIHRydWUpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBzdG9yZS5jb21taXQoYCR7bW9kdWxlTmFtZX0vJHtmZXRjaGVkRmllbGR9YCwgZmV0Y2hlZClcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWZldGNoZWQudGhlbikge1xyXG4gICAgICAgIGZldGNoZWQgPSBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmZXRjaGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChwcmVGZXRjaCkge1xyXG4gICAgICAgICAgcmV0dXJuIHByZUZldGNoLmFwcGx5KHNlbGYsIFsgY29udGV4dCBdKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuICBcclxuICAgIHBhZ2UuY3JlYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgbGV0IHNlbGYgPSB0aGlzXHJcbiAgICAgIGxldCBmZXRjaGVkICA9IHRoaXMuJHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdICYmIHRoaXMuJHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdW2ZldGNoZWRGaWVsZF1cclxuICAgICAgY2hlY2tNb2R1bGUoe1xyXG4gICAgICAgIHN0b3JlOiB0aGlzLiRzdG9yZSxcclxuICAgICAgICBmYWlsdXJlICgpIHtcclxuICAgICAgICAgIHNlbGYuJHN0b3JlLnJlZ2lzdGVyTW9kdWxlKG1vZHVsZU5hbWUsIHN0b3JlTW9kdWxlLCB7IHByZXNlcnZlU3RhdGU6IGZldGNoZWQgPT09IHRydWUgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIGlmIChjcmVhdGVkKSB7XHJcbiAgICAgICAgY3JlYXRlZC5hcHBseShzZWxmLCBbXSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHBhZ2UubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgbGV0IHNlbGYgPSB0aGlzXHJcbiAgICAgIGxldCBmZXRjaGVkICA9IHRoaXMuJHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdICYmIHRoaXMuJHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdW2ZldGNoZWRGaWVsZF1cclxuICAgICAgaWYgKCFmZXRjaGVkKSB7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuJHJvdXRlID8ge1xyXG4gICAgICAgICAgcm91dGU6IHRoaXMuJHJvdXRlLFxyXG4gICAgICAgICAgbmV4dDogdGhpcy4kcm91dGVyLnJlcGxhY2UuYmluZCh0aGlzLiRyb3V0ZXIpXHJcbiAgICAgICAgfSA6IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICBmZXRjaGVkID0gdGhpcy4kc3RvcmUuZGlzcGF0Y2goYCR7bW9kdWxlTmFtZX0vaW5pdGlhbGl6ZWAsIGFyZ3MpLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc2VsZi4kc3RvcmUuY29tbWl0KGAke21vZHVsZU5hbWV9LyR7ZmV0Y2hlZEZpZWxkfWAsIHRydWUpXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLiRzdG9yZS5jb21taXQoYCR7bW9kdWxlTmFtZX0vJHtmZXRjaGVkRmllbGR9YCwgZmV0Y2hlZClcclxuICAgICAgfVxyXG4gICAgICBpZiAobW91bnRlZCkge1xyXG4gICAgICAgIG1vdW50ZWQuYXBwbHkoc2VsZiwgW10pXHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIHBhZ2UuZGVzdHJveWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBsZXQgc2VsZiA9IHRoaXNcclxuICAgICAgaWYgKGRlc3Ryb3llZCkge1xyXG4gICAgICAgIGRlc3Ryb3llZC5hcHBseShzZWxmLCBbXSlcclxuICAgICAgfVxyXG4gICAgICBjaGVja01vZHVsZSh7XHJcbiAgICAgICAgc3RvcmU6IHRoaXMuJHN0b3JlLFxyXG4gICAgICAgIHN1Y2Nlc3MgKCkge1xyXG4gICAgICAgICAgc2VsZi4kc3RvcmUudW5yZWdpc3Rlck1vZHVsZShtb2R1bGVOYW1lKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubW9kZWwpIHtcclxuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMobmV3IG9wdGlvbnMubW9kZWwoKSlcclxuICAgIHBhZ2UuY29tcHV0ZWQgPSB7XHJcbiAgICAgIC4uLnBhZ2UuY29tcHV0ZWQsXHJcbiAgICAgIC4uLm1hcFN0YXRlKG1vZHVsZU5hbWUsIGtleXMpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbGxlY3Rpb25zKSB7XHJcbiAgICBsZXQgYWN0aW9ucyA9IHt9XHJcbiAgICBsZXQgZ2V0dGVycyA9IHt9XHJcbiAgICBsZXQgZGVmYXVsdFByZWZpeGVzID0gZ2V0Q29sbGVjdGlvblByZWZpeGVzKClcclxuICAgIGxldCBoYXNUeXBlcyA9IG9wdGlvbnMuY29sbGVjdGlvbnMuc29tZShjb2xsZWN0aW9uID0+IGNvbGxlY3Rpb24udHlwZSAhPT0gdm9pZCAwKVxyXG4gICAgaWYgKGhhc1R5cGVzKSB7XHJcbiAgICAgIGFjdGlvbnMuc2V0UHJvcGVydHlPZkFDb2xsZWN0aW9uSXRlbSA9IGZ1bmN0aW9uICh7IGlkLCBjb2xsZWN0aW9uLCBwcm9wZXJ0eSwgdmFsdWUgfSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5kaXNwYXRjaChgJHttb2R1bGVOYW1lfS9zZXRQcm9wZXJ0eU9mQUNvbGxlY3Rpb25JdGVtYCwgeyBpZCwgY29sbGVjdGlvbiwgcHJvcGVydHksIHZhbHVlIH0pXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBjb2xsZWN0aW9uIG9mIG9wdGlvbnMuY29sbGVjdGlvbnMpIHtcclxuICAgICAgbGV0IHNpbmdsZSA9IGdldENhc2VzKGNvbGxlY3Rpb24uc2luZ2xlKVxyXG4gICAgICBsZXQgcGx1cmFsID0gZ2V0Q2FzZXMoY29sbGVjdGlvbi5wbHVyYWwpXHJcbiAgICAgIGxldCB1cHNlcnRQcmVmaXggPSBjb2xsZWN0aW9uLnVwc2VydFByZWZpeCB8fCBkZWZhdWx0UHJlZml4ZXMudXBzZXJ0UHJlZml4XHJcbiAgICAgIGxldCBkZWxldGVQcmVmaXggPSBjb2xsZWN0aW9uLmRlbGV0ZVByZWZpeCB8fCBkZWZhdWx0UHJlZml4ZXMuZGVsZXRlUHJlZml4XHJcbiAgICAgIGFjdGlvbnNbYCR7dXBzZXJ0UHJlZml4fSR7c2luZ2xlLnBhc2NhbH1gXSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmRpc3BhdGNoKGAke21vZHVsZU5hbWV9LyR7dXBzZXJ0UHJlZml4fSR7c2luZ2xlLnBhc2NhbH1gLCBpdGVtKVxyXG4gICAgICB9XHJcbiAgICAgIGFjdGlvbnNbYCR7ZGVsZXRlUHJlZml4fSR7c2luZ2xlLnBhc2NhbH1gXSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5kaXNwYXRjaChgJHttb2R1bGVOYW1lfS8ke2RlbGV0ZVByZWZpeH0ke3NpbmdsZS5wYXNjYWx9YCwgaWQpXHJcbiAgICAgIH1cclxuICAgICAgZ2V0dGVyc1tgJHtwbHVyYWwuY2FtZWx9SW5kZXhgXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy4kc3RvcmUuZ2V0dGVyc1tgJHttb2R1bGVOYW1lfS8ke21vZHVsZU5hbWV9LyR7cGx1cmFsLmNhbWVsfUluZGV4YF1cclxuICAgICAgICBpZiAoZ2V0dGVyKSB7XHJcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdXHJcbiAgICAgICAgICByZXR1cm4gc3RvcmVNb2R1bGUuZ2V0dGVyc1tgJHtwbHVyYWwuY2FtZWx9SW5kZXhgXShzdGF0ZSwgdGhpcylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZ2V0dGVyc1tgJHtzaW5nbGUuY2FtZWx9QnlJZGBdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBnZXR0ZXIgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzW2Ake21vZHVsZU5hbWV9LyR7c2luZ2xlLmNhbWVsfUJ5SWRgXVxyXG4gICAgICAgIGlmIChnZXR0ZXIpIHtcclxuICAgICAgICAgIHJldHVybiBnZXR0ZXJcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy4kc3RvcmUuc3RhdGVbbW9kdWxlTmFtZV1cclxuICAgICAgICAgIHJldHVybiBzdG9yZU1vZHVsZS5nZXR0ZXJzW2Ake3NpbmdsZS5jYW1lbH1CeUlkYF0oc3RhdGUsIHRoaXMpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb2xsZWN0aW9uLnR5cGUgIT09IHZvaWQgMCkge1xyXG4gICAgICAgIGxldCBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMobmV3IGNvbGxlY3Rpb24udHlwZSgpKVxyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xyXG4gICAgICAgICAgbGV0IG5hbWUgPSBnZXRDYXNlcyhwcm9wZXJ0eSlcclxuICAgICAgICAgIGxldCBjb25qdW5jdGlvbiA9IHNpbmdsZS5wYXNjYWwubWF0Y2goL15bYWVpb3VdLiovaSkgPyAnQW4nIDogJ0EnXHJcbiAgICAgICAgICBsZXQgYWN0aW9uTmFtZSA9IGBzZXQke25hbWUucGFzY2FsfU9mJHtjb25qdW5jdGlvbn0ke3NpbmdsZS5wYXNjYWx9YFxyXG4gICAgICAgICAgYWN0aW9uc1thY3Rpb25OYW1lXSA9IGZ1bmN0aW9uICh7IGlkLCB2YWx1ZSB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5kaXNwYXRjaChgJHttb2R1bGVOYW1lfS8ke2FjdGlvbk5hbWV9YCwgeyBpZCwgY29sbGVjdGlvbjogY29sbGVjdGlvbi5wbHVyYWwsIHByb3BlcnR5LCB2YWx1ZSB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGFnZS5jb21wdXRlZCA9IHtcclxuICAgICAgLi4ucGFnZS5jb21wdXRlZCxcclxuICAgICAgLi4uZ2V0dGVyc1xyXG4gICAgfVxyXG4gICAgcGFnZS5tZXRob2RzID0ge1xyXG4gICAgICAuLi5wYWdlLm1ldGhvZHMsXHJcbiAgICAgIC4uLmFjdGlvbnNcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV4VHlwZXMpIHtcclxuICAgIGxldCBnZXR0ZXJzID0ge31cclxuICAgIGZvciAobGV0IGNvbXBsZXhUeXBlIG9mIG9wdGlvbnMuY29tcGxleFR5cGVzKSB7XHJcbiAgICAgIGxldCBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMobmV3IGNvbXBsZXhUeXBlLnR5cGUoKSlcclxuICAgICAgbGV0IHR5cGVOYW1lID0gZ2V0Q2FzZXMoY29tcGxleFR5cGUubmFtZSlcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENhc2VzKHByb3BlcnR5KVxyXG4gICAgICAgIGNvbnN0IGNhbWVsTmFtZSA9IGAke25hbWUuY2FtZWx9T2Yke3R5cGVOYW1lLnBhc2NhbH1gXHJcbiAgICAgICAgY29uc3QgcGFzY2FsTmFtZSA9IGBzZXQke25hbWUucGFzY2FsfU9mJHt0eXBlTmFtZS5wYXNjYWx9YFxyXG4gICAgICAgIGdldHRlcnNbY2FtZWxOYW1lXSA9IHtcclxuICAgICAgICAgIGdldCAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5zdGF0ZVttb2R1bGVOYW1lXVtjb21wbGV4VHlwZS5uYW1lXVtwcm9wZXJ0eV1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzZXQgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdChgJHttb2R1bGVOYW1lfS8ke3Bhc2NhbE5hbWV9YCwgdmFsdWUpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwYWdlLmNvbXB1dGVkID0ge1xyXG4gICAgICAuLi5wYWdlLmNvbXB1dGVkLFxyXG4gICAgICAuLi5nZXR0ZXJzXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBwYWdlXHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcbiAgcmVCcmFuZCxcclxuICBjb21wb25lbnQsXHJcbiAgc3RvcmUsXHJcbiAgcGFnZVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgcmVCcmFuZCxcclxuICBjb21wb25lbnQsXHJcbiAgc3RvcmUsXHJcbiAgcGFnZVxyXG59XHJcbiIsIi8qKlxyXG4gKiBjcmVhdGVzIGEgUHJvbWlzZSB3aG8gZG9lcyBub3RoaW5nIGFuZCB3aWxsIGJlIHJlc29sdmVkIGluIHggbWlsbGlzZWNvbmRzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHN1c3BlbmQgdGhlIGN1cnJlbnQgcHJvY2Vzcy5cclxuICogQHJldHVybnMge1Byb21pc2V9XHJcbiAqL1xyXG5jb25zdCBzbGVlcCA9IGZ1bmN0aW9uIChkZWxheSkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSlcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQge1xyXG4gIHNsZWVwXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBzbGVlcFxyXG59XHJcbiIsImltcG9ydCBmYWN0b3J5IGZyb20gJy4vZmFjdG9yeSdcclxuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnXHJcbmltcG9ydCB1dWlkIGZyb20gJy4vdXVpZCdcclxuaW1wb3J0IHRpbWVyIGZyb20gJy4vdGltZXInXHJcblxyXG5leHBvcnQgeyBmYWN0b3J5LCBzdG9yZSwgdXVpZCwgdGltZXIgfVxyXG5leHBvcnQgZGVmYXVsdCB7IGZhY3RvcnksIHN0b3JlLCB1dWlkLCB0aW1lciB9XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3JXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbmZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")}]);